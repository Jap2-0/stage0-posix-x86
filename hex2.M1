
# Core program
# Defining function exit
:FUNCTION_exit
POP_ebx
POP_ebx
LOAD_IMMEDIATE_eax %1
INT_80
RETURN
# Defining function fgetc
:FUNCTION_fgetc
LOAD_IMMEDIATE_eax %3
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
PUSH_ebx
COPY_esp_to_ecx
LOAD_IMMEDIATE_edx %1
INT_80
TEST
POP_eax
JUMP_NE8 !FUNCTION_fgetc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_fgetc_Done
RETURN
# Defining function fputc
:FUNCTION_fputc
LOAD_IMMEDIATE_eax %4
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_IMMEDIATE_edx %1
INT_80
RETURN
# Defining function open
:FUNCTION_open
LOAD_EFFECTIVE_ADDRESS_ebx %12
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_INTEGER_ecx
LOAD_EFFECTIVE_ADDRESS_edx %4
LOAD_INTEGER_edx
LOAD_IMMEDIATE_eax %5
INT_80
RETURN
# Defining function fopen
:FUNCTION_fopen
# Defining local f
PUSH_eax	#f
# IF_fopen_0
LOAD_IMMEDIATE_eax %119
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %577
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %384
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_fopen_0
:ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_fopen_0
# IF_fopen_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_fopen_1
:ELSE_fopen_1
:_END_IF_fopen_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function close
:FUNCTION_close
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_IMMEDIATE_eax %6
INT_80
RETURN
# Defining function fclose
:FUNCTION_fclose
# Defining local error
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_close
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#error
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function file_print
:FUNCTION_file_print
:WHILE_file_print_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_file_print_0
# THEN_while_file_print_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_file_print_0
:END_WHILE_file_print_0
RETURN
# Defining function malloc
:FUNCTION_malloc
STORE_eax_into_ESP_IMMEDIATE8 !4
PUSH_eax
LOAD_IMMEDIATE_eax %45
LOAD_IMMEDIATE_ebx %0
INT_80
POP_ebx
ADD_eax_to_ebx
PUSH_eax
PUSH_ebx
LOAD_IMMEDIATE_eax %45
INT_80
POP_ebx
CMP
POP_eax
JUMP_EQ8 !FUNCTION_malloc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_malloc_Done
RETURN
# Defining function memset
:FUNCTION_memset
# Defining local s
PUSH_eax	#s
# FOR_initialization_memset_0
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_memset_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %FOR_END_memset_0
JUMP %FOR_THEN_memset_0
:FOR_ITER_memset_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_memset_0
:FOR_THEN_memset_0
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_ITER_memset_0
:FOR_END_memset_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function calloc
:FUNCTION_calloc
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_malloc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_memset
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function free
:FUNCTION_free
RETURN
# Defining function match
:FUNCTION_match
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#i
:DO_match_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_match_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_match_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_match_1
:ELSE_match_1
:_END_IF_match_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_NE %DO_match_0
:DO_END_match_0
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
RETURN
# Defining function numerate_number
:FUNCTION_numerate_number
# Defining local result
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#result
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
# IF_numerate_number_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_number_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_numerate_number_0
:ELSE_numerate_number_0
:_END_IF_numerate_number_0
# IF_numerate_number_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_number_1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %45
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_numerate_number_1
:ELSE_numerate_number_1
:_END_IF_numerate_number_1
# Defining local divisor
LOAD_IMMEDIATE_eax %0x3B9ACA00
PUSH_eax	#divisor
:WHILE_numerate_number_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_numerate_number_2
# THEN_while_numerate_number_2
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_numerate_number_2
:END_WHILE_numerate_number_2
:WHILE_numerate_number_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %END_WHILE_numerate_number_3
# THEN_while_numerate_number_3
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_numerate_number_3
:END_WHILE_numerate_number_3
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function char2hex
:FUNCTION_char2hex
# IF_char2hex_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %57
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2hex_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2hex_0
:ELSE_char2hex_0
# IF_char2hex_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %97
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %102
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2hex_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %87
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2hex_1
:ELSE_char2hex_1
# IF_char2hex_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %65
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %70
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2hex_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %55
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2hex_2
:ELSE_char2hex_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_char2hex_2
:_END_IF_char2hex_1
:_END_IF_char2hex_0
RETURN
# Defining function hex2char
:FUNCTION_hex2char
# IF_hex2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %9
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_hex2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_hex2char_0
:ELSE_hex2char_0
# IF_hex2char_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %15
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_hex2char_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %55
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_hex2char_1
:ELSE_hex2char_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_hex2char_1
:_END_IF_hex2char_0
RETURN
# Defining function char2dec
:FUNCTION_char2dec
# IF_char2dec_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %57
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2dec_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2dec_0
:ELSE_char2dec_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_char2dec_0
RETURN
# Defining function dec2char
:FUNCTION_dec2char
# IF_dec2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %9
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_dec2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_dec2char_0
:ELSE_dec2char_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_dec2char_0
RETURN
# Defining function numerate_string
:FUNCTION_numerate_string
# Defining local count
LOAD_IMMEDIATE_eax %0
PUSH_eax	#count
# Defining local index
PUSH_eax	#index
# Defining local negative
PUSH_eax	#negative
# IF_numerate_string_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_0
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_numerate_string_0
:ELSE_numerate_string_0
# IF_numerate_string_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %120
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_numerate_string_1
# IF_numerate_string_2
LOAD_IMMEDIATE_eax %45
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_2
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_numerate_string_2
:ELSE_numerate_string_2
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_numerate_string_2
:WHILE_numerate_string_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_numerate_string_3
# THEN_while_numerate_string_3
# IF_numerate_string_4
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_char2hex
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_4
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_numerate_string_4
:ELSE_numerate_string_4
:_END_IF_numerate_string_4
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_char2hex
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_numerate_string_3
:END_WHILE_numerate_string_3
JUMP %_END_IF_numerate_string_1
:ELSE_numerate_string_1
# IF_numerate_string_5
LOAD_IMMEDIATE_eax %45
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_5
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_numerate_string_5
:ELSE_numerate_string_5
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_numerate_string_5
:WHILE_numerate_string_6
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_numerate_string_6
# THEN_while_numerate_string_6
# IF_numerate_string_7
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_char2dec
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_7
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_numerate_string_7
:ELSE_numerate_string_7
:_END_IF_numerate_string_7
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_char2dec
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_numerate_string_6
:END_WHILE_numerate_string_6
:_END_IF_numerate_string_1
:_END_IF_numerate_string_0
# IF_numerate_string_8
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_numerate_string_8
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_numerate_string_8
:ELSE_numerate_string_8
:_END_IF_numerate_string_8
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function in_set
:FUNCTION_in_set
:WHILE_in_set_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_in_set_0
# THEN_while_in_set_0
# IF_in_set_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_in_set_1
LOAD_IMMEDIATE_eax %1
RETURN
JUMP %_END_IF_in_set_1
:ELSE_in_set_1
:_END_IF_in_set_1
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_in_set_0
:END_WHILE_in_set_0
LOAD_IMMEDIATE_eax %0
RETURN
# Defining function chmod
:FUNCTION_chmod
LOAD_EFFECTIVE_ADDRESS_ebx %8
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %4
LOAD_INTEGER_ecx
LOAD_IMMEDIATE_eax %15
INT_80
RETURN
# Defining function line_error
:FUNCTION_line_error
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_filename
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_line_error_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_line_error_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function consume_token
:FUNCTION_consume_token
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
:WHILE_consume_token_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_consume_token_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %END_WHILE_consume_token_0
# THEN_while_consume_token_0
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_consume_token_0
:END_WHILE_consume_token_0
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function Throwaway_token
:FUNCTION_Throwaway_token
# Defining local c
PUSH_eax	#c
:DO_Throwaway_token_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_Throwaway_token_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_NE %DO_Throwaway_token_0
:DO_END_Throwaway_token_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function length
:FUNCTION_length
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
:WHILE_length_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_length_0
# THEN_while_length_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_length_0
:END_WHILE_length_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function Clear_Scratch
:FUNCTION_Clear_Scratch
:DO_Clear_Scratch_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_NE %DO_Clear_Scratch_0
:DO_END_Clear_Scratch_0
RETURN
# Defining function Copy_String
:FUNCTION_Copy_String
:WHILE_Copy_String_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_Copy_String_0
# THEN_while_Copy_String_0
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_Copy_String_0
:END_WHILE_Copy_String_0
RETURN
# Defining function GetTarget
:FUNCTION_GetTarget
# Defining local i
PUSH_eax	#i
# FOR_initialization_GetTarget_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_GetTarget_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_GetTarget_0
JUMP %FOR_THEN_GetTarget_0
:FOR_ITER_GetTarget_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_GetTarget_0
:FOR_THEN_GetTarget_0
# IF_GetTarget_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_GetTarget_1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_GetTarget_1
:ELSE_GetTarget_1
:_END_IF_GetTarget_1
JUMP %FOR_ITER_GetTarget_0
:FOR_END_GetTarget_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_GetTarget_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_GetTarget_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function storeLabel
:FUNCTION_storeLabel
# Defining local entry
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %12
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#entry
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_length
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Copy_String
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Clear_Scratch
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function range_check
:FUNCTION_range_check
# IF_range_check_0
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_0
RETURN
JUMP %_END_IF_range_check_0
:ELSE_range_check_0
# IF_range_check_1
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_1
# IF_range_check_2
LOAD_IMMEDIATE_eax %8388607
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8388608
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_range_check_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_range_check_2
:ELSE_range_check_2
:_END_IF_range_check_2
RETURN
JUMP %_END_IF_range_check_1
:ELSE_range_check_1
# IF_range_check_5
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_5
# IF_range_check_6
LOAD_IMMEDIATE_eax %32767
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32768
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_range_check_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_range_check_6
:ELSE_range_check_6
:_END_IF_range_check_6
RETURN
JUMP %_END_IF_range_check_5
:ELSE_range_check_5
# IF_range_check_9
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_9
# IF_range_check_10
LOAD_IMMEDIATE_eax %127
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %128
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_range_check_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_11
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_range_check_10
:ELSE_range_check_10
:_END_IF_range_check_10
RETURN
JUMP %_END_IF_range_check_9
:ELSE_range_check_9
:_END_IF_range_check_9
:_END_IF_range_check_5
:_END_IF_range_check_1
:_END_IF_range_check_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_range_check_13
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function outputPointer
:FUNCTION_outputPointer
# Defining local value
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#value
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_range_check
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_outputPointer_0
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_outputPointer_0
# IF_outputPointer_1
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_outputPointer_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %24
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_outputPointer_1
:ELSE_outputPointer_1
:_END_IF_outputPointer_1
# IF_outputPointer_2
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %ELSE_outputPointer_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %256
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_outputPointer_2
:ELSE_outputPointer_2
:_END_IF_outputPointer_2
# IF_outputPointer_3
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %ELSE_outputPointer_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %256
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_outputPointer_3
:ELSE_outputPointer_3
:_END_IF_outputPointer_3
# IF_outputPointer_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %ELSE_outputPointer_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %256
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_outputPointer_4
:ELSE_outputPointer_4
:_END_IF_outputPointer_4
JUMP %_END_IF_outputPointer_0
:ELSE_outputPointer_0
:WHILE_outputPointer_5
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %END_WHILE_outputPointer_5
# THEN_while_outputPointer_5
# Defining local byte
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %256
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
PUSH_eax	#byte
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %256
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %WHILE_outputPointer_5
:END_WHILE_outputPointer_5
:_END_IF_outputPointer_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function Architectural_displacement
:FUNCTION_Architectural_displacement
# IF_Architectural_displacement_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Architectural_displacement_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_Architectural_displacement_0
:ELSE_Architectural_displacement_0
# IF_Architectural_displacement_1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Architectural_displacement_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_Architectural_displacement_1
:ELSE_Architectural_displacement_1
# IF_Architectural_displacement_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Architectural_displacement_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_Architectural_displacement_2
:ELSE_Architectural_displacement_2
# IF_Architectural_displacement_3
LOAD_IMMEDIATE_eax &GLOBAL_ALIGNED
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %40
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_Architectural_displacement_3
LOAD_IMMEDIATE_eax &GLOBAL_ALIGNED
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_Architectural_displacement_4
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_Architectural_displacement_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_Architectural_displacement_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_Architectural_displacement_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_Architectural_displacement_4
:ELSE_Architectural_displacement_4
:_END_IF_Architectural_displacement_4
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_Architectural_displacement_3
:ELSE_Architectural_displacement_3
# IF_Architectural_displacement_7
LOAD_IMMEDIATE_eax %40
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Architectural_displacement_7
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_Architectural_displacement_7
:ELSE_Architectural_displacement_7
:_END_IF_Architectural_displacement_7
:_END_IF_Architectural_displacement_3
:_END_IF_Architectural_displacement_2
:_END_IF_Architectural_displacement_1
:_END_IF_Architectural_displacement_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_Architectural_displacement_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function Update_Pointer
:FUNCTION_Update_Pointer
# IF_Update_Pointer_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_Update_Pointer_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_Update_Pointer_0
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_Update_Pointer_0
:ELSE_Update_Pointer_0
# IF_Update_Pointer_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_Update_Pointer_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_Update_Pointer_2
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_Update_Pointer_2
:ELSE_Update_Pointer_2
# IF_Update_Pointer_4
LOAD_IMMEDIATE_eax %126
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Update_Pointer_4
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_Update_Pointer_4
:ELSE_Update_Pointer_4
# IF_Update_Pointer_5
LOAD_IMMEDIATE_eax %33
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Update_Pointer_5
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_Update_Pointer_5
:ELSE_Update_Pointer_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_Update_Pointer_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_Update_Pointer_5
:_END_IF_Update_Pointer_4
:_END_IF_Update_Pointer_2
:_END_IF_Update_Pointer_0
RETURN
# Defining function storePointer
:FUNCTION_storePointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Clear_Scratch
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Update_Pointer
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local base_sep_p
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#base_sep_p
# Defining local target
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_GetTarget
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#target
# Defining local displacement
PUSH_eax	#displacement
# Defining local base
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#base
# IF_storePointer_0
LOAD_IMMEDIATE_eax %62
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Clear_Scratch
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-28
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_scratch
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_GetTarget
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_storePointer_0
:ELSE_storePointer_0
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Architectural_displacement
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_storePointer_0
# IF_storePointer_1
LOAD_IMMEDIATE_eax %33
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_outputPointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_storePointer_1
:ELSE_storePointer_1
# IF_storePointer_2
LOAD_IMMEDIATE_eax %36
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_outputPointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_storePointer_2
:ELSE_storePointer_2
# IF_storePointer_3
LOAD_IMMEDIATE_eax %64
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_outputPointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_storePointer_3
:ELSE_storePointer_3
# IF_storePointer_4
LOAD_IMMEDIATE_eax %126
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_outputPointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_storePointer_4
:ELSE_storePointer_4
# IF_storePointer_5
LOAD_IMMEDIATE_eax %38
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_outputPointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_storePointer_5
:ELSE_storePointer_5
# IF_storePointer_6
LOAD_IMMEDIATE_eax %37
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storePointer_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_outputPointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_storePointer_6
:ELSE_storePointer_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_storePointer_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_storePointer_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_storePointer_6
:_END_IF_storePointer_5
:_END_IF_storePointer_4
:_END_IF_storePointer_3
:_END_IF_storePointer_2
:_END_IF_storePointer_1
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function line_Comment
:FUNCTION_line_Comment
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
:WHILE_line_Comment_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_line_Comment_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %END_WHILE_line_Comment_0
# THEN_while_line_Comment_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_line_Comment_0
:END_WHILE_line_Comment_0
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function hex
:FUNCTION_hex
# IF_hex_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_hex_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_hex_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_hex_0
:ELSE_hex_0
# IF_hex_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_hex_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_hex_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %87
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_hex_2
:ELSE_hex_2
# IF_hex_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_hex_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_hex_4
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %55
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_hex_4
:ELSE_hex_4
# IF_hex_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_hex_7
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_hex_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_Comment
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_hex_6
:ELSE_hex_6
# IF_hex_8
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_hex_8
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_hex_8
:ELSE_hex_8
:_END_IF_hex_8
:_END_IF_hex_6
:_END_IF_hex_4
:_END_IF_hex_2
:_END_IF_hex_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
# Defining function octal
:FUNCTION_octal
# IF_octal_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_octal_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_octal_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_octal_0
:ELSE_octal_0
# IF_octal_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_octal_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_octal_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_Comment
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_octal_2
:ELSE_octal_2
# IF_octal_4
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_octal_4
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_octal_4
:ELSE_octal_4
:_END_IF_octal_4
:_END_IF_octal_2
:_END_IF_octal_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
# Defining function binary
:FUNCTION_binary
# IF_binary_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_binary_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_binary_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_binary_0
:ELSE_binary_0
# IF_binary_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_binary_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_binary_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_Comment
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_binary_2
:ELSE_binary_2
# IF_binary_4
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_binary_4
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_binary_4
:ELSE_binary_4
:_END_IF_binary_4
:_END_IF_binary_2
:_END_IF_binary_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
# Defining function process_byte
:FUNCTION_process_byte
# IF_process_byte_0
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_0
# IF_process_byte_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_hex
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_1
# IF_process_byte_2
LOAD_IMMEDIATE_eax &GLOBAL_toggle
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_process_byte_2
# IF_process_byte_3
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_process_byte_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_hold
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_hex
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_byte_3
:ELSE_process_byte_3
:_END_IF_process_byte_3
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_process_byte_2
:ELSE_process_byte_2
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_hex
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_process_byte_2
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_toggle
LOAD_INTEGER
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_process_byte_1
:ELSE_process_byte_1
:_END_IF_process_byte_1
JUMP %_END_IF_process_byte_0
:ELSE_process_byte_0
# IF_process_byte_4
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_4
# IF_process_byte_5
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_octal
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_5
# IF_process_byte_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_toggle
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_6
# IF_process_byte_7
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_process_byte_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_hold
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_octal
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_byte_7
:ELSE_process_byte_7
:_END_IF_process_byte_7
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_process_byte_6
:ELSE_process_byte_6
# IF_process_byte_8
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_toggle
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_8
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_hold
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_octal
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_process_byte_8
:ELSE_process_byte_8
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_octal
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_process_byte_8
:_END_IF_process_byte_6
JUMP %_END_IF_process_byte_5
:ELSE_process_byte_5
:_END_IF_process_byte_5
JUMP %_END_IF_process_byte_4
:ELSE_process_byte_4
# IF_process_byte_9
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_9
# IF_process_byte_10
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_binary
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_10
# IF_process_byte_11
LOAD_IMMEDIATE_eax %7
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_toggle
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_byte_11
# IF_process_byte_12
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_process_byte_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_hold
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_binary
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_byte_12
:ELSE_process_byte_12
:_END_IF_process_byte_12
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_process_byte_11
:ELSE_process_byte_11
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_hold
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_binary
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_toggle
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_process_byte_11
JUMP %_END_IF_process_byte_10
:ELSE_process_byte_10
:_END_IF_process_byte_10
JUMP %_END_IF_process_byte_9
:ELSE_process_byte_9
:_END_IF_process_byte_9
:_END_IF_process_byte_4
:_END_IF_process_byte_0
RETURN
# Defining function pad_to_align
:FUNCTION_pad_to_align
# IF_pad_to_align_0
LOAD_IMMEDIATE_eax %40
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_pad_to_align_0
# IF_pad_to_align_1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0x1
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_pad_to_align_1
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_pad_to_align_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_pad_to_align_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_pad_to_align_2
:ELSE_pad_to_align_2
:_END_IF_pad_to_align_2
JUMP %_END_IF_pad_to_align_1
:ELSE_pad_to_align_1
:_END_IF_pad_to_align_1
# IF_pad_to_align_3
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0x2
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_pad_to_align_3
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_pad_to_align_4
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_pad_to_align_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_pad_to_align_4
:ELSE_pad_to_align_4
:_END_IF_pad_to_align_4
JUMP %_END_IF_pad_to_align_3
:ELSE_pad_to_align_3
:_END_IF_pad_to_align_3
JUMP %_END_IF_pad_to_align_0
:ELSE_pad_to_align_0
:_END_IF_pad_to_align_0
RETURN
# Defining function first_pass
:FUNCTION_first_pass
# IF_first_pass_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_0
RETURN
JUMP %_END_IF_first_pass_0
:ELSE_first_pass_0
:_END_IF_first_pass_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_first_pass
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_filename
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local source_file
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_filename
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_first_pass_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#source_file
# IF_first_pass_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_first_pass_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_first_pass_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_first_pass_2
:ELSE_first_pass_2
:_END_IF_first_pass_2
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local c
PUSH_eax	#c
# FOR_initialization_first_pass_5
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_first_pass_5
LOAD_IMMEDIATE_eax %0xFFFFFFFF
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_first_pass_5
JUMP %FOR_THEN_first_pass_5
:FOR_ITER_first_pass_5
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_first_pass_5
:FOR_THEN_first_pass_5
# IF_first_pass_6
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_6
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_ip
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_storeLabel
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_first_pass_6
:ELSE_first_pass_6
:_END_IF_first_pass_6
# IF_first_pass_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_first_pass_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_first_pass_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Update_Pointer
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Throwaway_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_first_pass_9
LOAD_IMMEDIATE_eax %62
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_9
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Throwaway_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_first_pass_9
:ELSE_first_pass_9
:_END_IF_first_pass_9
JUMP %_END_IF_first_pass_7
:ELSE_first_pass_7
# IF_first_pass_10
LOAD_IMMEDIATE_eax %60
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_pad_to_align
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_first_pass_10
:ELSE_first_pass_10
# IF_first_pass_11
LOAD_IMMEDIATE_eax %94
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_11

#continue statement
JUMP %_END_IF_first_pass_11
:ELSE_first_pass_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_byte
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_first_pass_11
:_END_IF_first_pass_10
:_END_IF_first_pass_7
JUMP %FOR_ITER_first_pass_5
:FOR_END_first_pass_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fclose
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function second_pass
:FUNCTION_second_pass
# IF_second_pass_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_second_pass_0
RETURN
JUMP %_END_IF_second_pass_0
:ELSE_second_pass_0
:_END_IF_second_pass_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_second_pass
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_filename
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_linenumber
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local source_file
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_filename
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_second_pass_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#source_file
# IF_second_pass_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_second_pass_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_second_pass_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_second_pass_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_second_pass_2
:ELSE_second_pass_2
:_END_IF_second_pass_2
LOAD_IMMEDIATE_eax &GLOBAL_toggle
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local c
PUSH_eax	#c
# FOR_initialization_second_pass_5
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_second_pass_5
LOAD_IMMEDIATE_eax %0xFFFFFFFF
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_second_pass_5
JUMP %FOR_THEN_second_pass_5
:FOR_ITER_second_pass_5
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_second_pass_5
:FOR_THEN_second_pass_5
# IF_second_pass_6
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_second_pass_6
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_Throwaway_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_second_pass_6
:ELSE_second_pass_6
# IF_second_pass_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_second_pass_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_second_pass_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_storePointer
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_second_pass_7
:ELSE_second_pass_7
# IF_second_pass_9
LOAD_IMMEDIATE_eax %60
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_second_pass_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_pad_to_align
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_second_pass_9
:ELSE_second_pass_9
# IF_second_pass_10
LOAD_IMMEDIATE_eax %94
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_second_pass_10
LOAD_IMMEDIATE_eax &GLOBAL_ALIGNED
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_second_pass_10
:ELSE_second_pass_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_byte
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_second_pass_10
:_END_IF_second_pass_9
:_END_IF_second_pass_7
:_END_IF_second_pass_6
JUMP %FOR_ITER_second_pass_5
:FOR_END_second_pass_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fclose
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function main
:FUNCTION_main
LOAD_IMMEDIATE_eax &GLOBAL_ALIGNED
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_Base_Address
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local input
LOAD_IMMEDIATE_eax %0
PUSH_eax	#input
LOAD_IMMEDIATE_eax &GLOBAL_output
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local output_file
LOAD_IMMEDIATE_eax &STRING_main_0
PUSH_eax	#output_file
LOAD_IMMEDIATE_eax &GLOBAL_exec_enable
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_scratch
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local arch
PUSH_eax	#arch
# Defining local option_index
LOAD_IMMEDIATE_eax %1
PUSH_eax	#option_index
:WHILE_main_1
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_main_1
# THEN_while_main_1
# IF_main_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_2
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_2
:ELSE_main_2
# IF_main_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_3
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_3
:ELSE_main_3
# IF_main_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_6
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_5
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_5
:ELSE_main_5
# IF_main_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_7
LOAD_IMMEDIATE_eax &GLOBAL_exec_enable
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_7
:ELSE_main_7
# IF_main_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_10
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_11
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_9
LOAD_BASE_ADDRESS_eax %-28
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_13
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_14
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_12
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_12
:ELSE_main_12
# IF_main_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_16
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_15
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_15
:ELSE_main_15
# IF_main_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_18
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_17
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_17
:ELSE_main_17
# IF_main_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_20
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_19
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %40
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_19
:ELSE_main_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_21
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_22
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_main_19
:_END_IF_main_17
:_END_IF_main_15
:_END_IF_main_12
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_9
:ELSE_main_9
# IF_main_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_24
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_25
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_23
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_23
:ELSE_main_23
# IF_main_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_27
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_26
LOAD_IMMEDIATE_eax &GLOBAL_Base_Address
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_26
:ELSE_main_26
# IF_main_29
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_30
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_31
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_29
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_32
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_33
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_34
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_35
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_36
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_29
:ELSE_main_29
# IF_main_37
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_38
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_39
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_37
# Defining local temp
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#temp
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_main_37
:ELSE_main_37
# IF_main_40
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_41
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_42
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_40
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_output
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_43
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_44
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_44
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_45
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_46
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_44
:ELSE_main_44
:_END_IF_main_44
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_40
:ELSE_main_40
# IF_main_47
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_48
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_49
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_47
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_47
:ELSE_main_47
# IF_main_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_51
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_52
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_53
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_50
:ELSE_main_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_54
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_main_50
:_END_IF_main_47
:_END_IF_main_40
:_END_IF_main_37
:_END_IF_main_29
:_END_IF_main_26
:_END_IF_main_23
:_END_IF_main_9
:_END_IF_main_7
:_END_IF_main_5
:_END_IF_main_3
:_END_IF_main_2
JUMP %WHILE_main_1
:END_WHILE_main_1
# IF_main_55
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_55
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_main_55
:ELSE_main_55
:_END_IF_main_55
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Base_Address
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_first_pass
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_ip
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Base_Address
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_second_pass
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_main_56
LOAD_IMMEDIATE_eax &GLOBAL_exec_enable
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_main_56
# IF_main_57
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %488
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_chmod
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_57
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_58
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_57
:ELSE_main_57
:_END_IF_main_57
JUMP %_END_IF_main_56
:ELSE_main_56
:_END_IF_main_56
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN

:ELF_data

# Program global variables
:GLOBAL_output
NOP
:GLOBAL_jump_table
NOP
:GLOBAL_BigEndian
NOP
:GLOBAL_Base_Address
NOP
:GLOBAL_Architecture
NOP
:GLOBAL_ByteMode
NOP
:GLOBAL_exec_enable
NOP
:GLOBAL_ip
NOP
:GLOBAL_scratch
NOP
:GLOBAL_filename
NOP
:GLOBAL_linenumber
NOP
:GLOBAL_ALIGNED
NOP
:GLOBAL_hold
NOP
:GLOBAL_toggle
NOP

# Program strings
:STRING_line_error_0
":"
:STRING_line_error_1
' 20 3A 00'
:STRING_consume_token_1
" 	
>"
:STRING_Throwaway_token_1
" 	
>"
:STRING_GetTarget_2
"Target label "
:STRING_GetTarget_3
" is not valid
"
:STRING_range_check_3
"A displacement of "
:STRING_range_check_4
" does not fit in 3 bytes
"
:STRING_range_check_7
"A displacement of "
:STRING_range_check_8
" does not fit in 2 bytes
"
:STRING_range_check_11
"A displacement of "
:STRING_range_check_12
" does not fit in 1 byte
"
:STRING_range_check_13
"Invalid number of bytes given
"
:STRING_Architectural_displacement_5
"error: Unaligned branch target: "
:STRING_Architectural_displacement_6
", aborting
"
:STRING_Architectural_displacement_8
"Unknown Architecture, aborting before harm is done
"
:STRING_Update_Pointer_1
"%&"
:STRING_Update_Pointer_3
"@$"
:STRING_Update_Pointer_6
"storePointer given unknown
"
:STRING_storePointer_7
"error: storePointer reached impossible case: ch="
:STRING_storePointer_8
"
"
:STRING_line_Comment_1
' 0A 0D 00'
:STRING_hex_1
"0123456789"
:STRING_hex_3
"abcdef"
:STRING_hex_5
"ABCDEF"
:STRING_hex_7
"#;"
:STRING_octal_1
"01234567"
:STRING_octal_3
"#;"
:STRING_binary_1
"01"
:STRING_binary_3
"#;"
:STRING_first_pass_1
"r"
:STRING_first_pass_3
"The file: "
:STRING_first_pass_4
" can not be opened!
"
:STRING_first_pass_8
"!@$~%&"
:STRING_second_pass_1
"r"
:STRING_second_pass_3
"The file: "
:STRING_second_pass_4
" can not be opened!
WTF-pass2
"
:STRING_second_pass_8
"!@$~%&"
:STRING_main_0
""
:STRING_main_4
"--BigEndian"
:STRING_main_6
"--LittleEndian"
:STRING_main_8
"--exec_enable"
:STRING_main_10
"-A"
:STRING_main_11
"--architecture"
:STRING_main_13
"knight-native"
:STRING_main_14
"knight-posix"
:STRING_main_16
"x86"
:STRING_main_18
"amd64"
:STRING_main_20
"armv7l"
:STRING_main_21
"Unknown architecture: "
:STRING_main_22
" know values are: knight-native, knight-posix, x86, amd64 and armv7l"
:STRING_main_24
"-b"
:STRING_main_25
"--binary"
:STRING_main_27
"-B"
:STRING_main_28
"--BaseAddress"
:STRING_main_30
"-h"
:STRING_main_31
"--help"
:STRING_main_32
"Usage: "
:STRING_main_33
" -f FILENAME1 {-f FILENAME2} (--BigEndian|--LittleEndian)"
:STRING_main_34
" [--BaseAddress 12345] [--architecture name]
Architecture"
:STRING_main_35
" knight-native, knight-posix, x86, amd64 and armv7
"
:STRING_main_36
"To leverage octal or binary input: --octal, --binary
"
:STRING_main_38
"-f"
:STRING_main_39
"--file"
:STRING_main_41
"-o"
:STRING_main_42
"--output"
:STRING_main_43
"w"
:STRING_main_45
"The file: "
:STRING_main_46
" can not be opened!
"
:STRING_main_48
"-O"
:STRING_main_49
"--octal"
:STRING_main_51
"-V"
:STRING_main_52
"--version"
:STRING_main_53
"hex2 0.3
"
:STRING_main_54
"Unknown option
"
:STRING_main_58
"Unable to change permissions
"
