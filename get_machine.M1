
# Core program
# Defining function exit
:FUNCTION_exit
POP_ebx
POP_ebx
LOAD_IMMEDIATE_eax %1
INT_80
RETURN
# Defining function fgetc
:FUNCTION_fgetc
LOAD_IMMEDIATE_eax %3
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
PUSH_ebx
COPY_esp_to_ecx
LOAD_IMMEDIATE_edx %1
INT_80
TEST
POP_eax
JUMP_NE8 !FUNCTION_fgetc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_fgetc_Done
RETURN
# Defining function fputc
:FUNCTION_fputc
LOAD_IMMEDIATE_eax %4
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_IMMEDIATE_edx %1
INT_80
RETURN
# Defining function open
:FUNCTION_open
LOAD_EFFECTIVE_ADDRESS_ebx %12
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_INTEGER_ecx
LOAD_EFFECTIVE_ADDRESS_edx %4
LOAD_INTEGER_edx
LOAD_IMMEDIATE_eax %5
INT_80
RETURN
# Defining function fopen
:FUNCTION_fopen
# Defining local f
PUSH_eax	#f
# IF_fopen_0
LOAD_IMMEDIATE_eax %119
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %577
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %384
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_fopen_0
:ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_fopen_0
# IF_fopen_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_fopen_1
:ELSE_fopen_1
:_END_IF_fopen_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function close
:FUNCTION_close
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_IMMEDIATE_eax %6
INT_80
RETURN
# Defining function fclose
:FUNCTION_fclose
# Defining local error
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_close
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#error
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function file_print
:FUNCTION_file_print
:WHILE_file_print_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_file_print_0
# THEN_while_file_print_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_file_print_0
:END_WHILE_file_print_0
RETURN
# Defining function malloc
:FUNCTION_malloc
STORE_eax_into_ESP_IMMEDIATE8 !4
PUSH_eax
LOAD_IMMEDIATE_eax %45
LOAD_IMMEDIATE_ebx %0
INT_80
POP_ebx
ADD_eax_to_ebx
PUSH_eax
PUSH_ebx
LOAD_IMMEDIATE_eax %45
INT_80
POP_ebx
CMP
POP_eax
JUMP_EQ8 !FUNCTION_malloc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_malloc_Done
RETURN
# Defining function memset
:FUNCTION_memset
# Defining local s
PUSH_eax	#s
# FOR_initialization_memset_0
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_memset_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %FOR_END_memset_0
JUMP %FOR_THEN_memset_0
:FOR_ITER_memset_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_memset_0
:FOR_THEN_memset_0
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_ITER_memset_0
:FOR_END_memset_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function calloc
:FUNCTION_calloc
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_malloc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_memset
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function free
:FUNCTION_free
RETURN
# Defining function uname
:FUNCTION_uname
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
LOAD_IMMEDIATE_eax %109
INT_80
RETURN
# Defining function main
:FUNCTION_main
# Defining local unameData
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %325
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#unameData
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uname
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %260
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN

:ELF_data

# Program global variables

# Program strings
:STRING_main_0
"
"
