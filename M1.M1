
# Core program

# Defining function newToken
:FUNCTION_newToken
# Defining local p
PUSH_eax	#p
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_newToken_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_newToken_0

LOAD_IMMEDIATE_eax &STRING_0

PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_newToken_0

:ELSE_newToken_0

:_END_IF_newToken_0

LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function reverse_list
:FUNCTION_reverse_list
# Defining local root
LOAD_IMMEDIATE_eax %0
PUSH_eax	#root
:WHILE_reverse_list_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_reverse_list_0

# THEN_while_reverse_list_0

# Defining local next
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#next
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %12
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %WHILE_reverse_list_0

:END_WHILE_reverse_list_0

LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function purge_lineComment
:FUNCTION_purge_lineComment
# Defining local c
LOAD_IMMEDIATE_eax &GLOBAL_source_file
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
PUSH_eax	#c
:WHILE_purge_lineComment_0

LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %13
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %END_WHILE_purge_lineComment_0

# THEN_while_purge_lineComment_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_source_file
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_purge_lineComment_0

:END_WHILE_purge_lineComment_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function store_atom
:FUNCTION_store_atom
# Defining local store
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#store
# IF_store_atom_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_store_atom_0

LOAD_IMMEDIATE_eax &STRING_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_store_atom_0

:ELSE_store_atom_0

:_END_IF_store_atom_0

# Defining local ch
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#ch
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
:DO_store_atom_1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_source_file
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax %9
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4096
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_NE %DO_store_atom_1
:DO_END_store_atom_1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function store_string
:FUNCTION_store_string
# Defining local store
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#store
# IF_store_string_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_store_string_0

LOAD_IMMEDIATE_eax &STRING_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_store_string_0

:ELSE_store_string_0

:_END_IF_store_string_0

# Defining local ch
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#ch
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
:DO_store_string_1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_source_file
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_store_string_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_store_string_2
LOAD_IMMEDIATE_eax &STRING_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_store_string_2
:ELSE_store_string_2
:_END_IF_store_string_2
# IF_store_string_3
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_store_string_3
LOAD_IMMEDIATE_eax &STRING_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_store_string_3
:ELSE_store_string_3
:_END_IF_store_string_3
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_NE %DO_store_string_1
:DO_END_store_string_1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function Tokenize_Line
:FUNCTION_Tokenize_Line
# Defining local c
PUSH_eax	#c
# Defining local p
PUSH_eax	#p
:DO_Tokenize_Line_0

:restart	#C goto label
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_source_file
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_Tokenize_Line_1
LOAD_IMMEDIATE_eax %35
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %59
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_Tokenize_Line_1
CALL_IMMEDIATE %FUNCTION_purge_lineComment
JUMP %restart
JUMP %_END_IF_Tokenize_Line_1
:ELSE_Tokenize_Line_1
:_END_IF_Tokenize_Line_1
# IF_Tokenize_Line_2
LOAD_IMMEDIATE_eax %9
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_Tokenize_Line_2
JUMP %restart
JUMP %_END_IF_Tokenize_Line_2
:ELSE_Tokenize_Line_2
:_END_IF_Tokenize_Line_2
# IF_Tokenize_Line_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_Tokenize_Line_3
JUMP %done
JUMP %_END_IF_Tokenize_Line_3
:ELSE_Tokenize_Line_3
:_END_IF_Tokenize_Line_3
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
CALL_IMMEDIATE %FUNCTION_newToken
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_Tokenize_Line_4
LOAD_IMMEDIATE_eax %34
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %39
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_Tokenize_Line_4
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_store_string
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_Tokenize_Line_4
:ELSE_Tokenize_Line_4
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_store_atom
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_Tokenize_Line_4
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %12
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax %1
TEST
JUMP_NE %DO_Tokenize_Line_0

:DO_END_Tokenize_Line_0

:done	#C goto label
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function setExpression
:FUNCTION_setExpression
# Defining local i
PUSH_eax	#i
# FOR_initialization_setExpression_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_setExpression_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_setExpression_0

JUMP %FOR_THEN_setExpression_0

:FOR_ITER_setExpression_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_setExpression_0

:FOR_THEN_setExpression_0

# IF_setExpression_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_setExpression_1

#continue statement
JUMP %_END_IF_setExpression_1
:ELSE_setExpression_1
# IF_setExpression_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
TEST
JUMP_EQ %ELSE_setExpression_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_setExpression_2
:ELSE_setExpression_2
:_END_IF_setExpression_2
:_END_IF_setExpression_1
JUMP %FOR_ITER_setExpression_0

:FOR_END_setExpression_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function identify_macros
:FUNCTION_identify_macros
# Defining local i
PUSH_eax	#i
# FOR_initialization_identify_macros_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_identify_macros_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_identify_macros_0

JUMP %FOR_THEN_identify_macros_0

:FOR_ITER_identify_macros_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_identify_macros_0

:FOR_THEN_identify_macros_0

# IF_identify_macros_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_6
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
TEST
JUMP_EQ %ELSE_identify_macros_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_identify_macros_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_identify_macros_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_identify_macros_2
:ELSE_identify_macros_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_identify_macros_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_identify_macros_1
:ELSE_identify_macros_1
:_END_IF_identify_macros_1
JUMP %FOR_ITER_identify_macros_0

:FOR_END_identify_macros_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function line_macro
:FUNCTION_line_macro
# Defining local i
PUSH_eax	#i
# FOR_initialization_line_macro_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_line_macro_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_line_macro_0

JUMP %FOR_THEN_line_macro_0

:FOR_ITER_line_macro_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_line_macro_0

:FOR_THEN_line_macro_0

# IF_line_macro_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_line_macro_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_setExpression
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
JUMP %_END_IF_line_macro_1
:ELSE_line_macro_1
:_END_IF_line_macro_1
JUMP %FOR_ITER_line_macro_0

:FOR_END_line_macro_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function hexify_string
:FUNCTION_hexify_string
# Defining local table
LOAD_IMMEDIATE_eax &STRING_7
PUSH_eax	#table
# Defining local i
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_string_length
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#i
# Defining local d
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#d
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:WHILE_hexify_string_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %END_WHILE_hexify_string_0

# THEN_while_hexify_string_0

LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0x30
POP_ebx	# _common_recursion
STORE_CHAR
JUMP %WHILE_hexify_string_0

:END_WHILE_hexify_string_0

:WHILE_hexify_string_1
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4096
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %END_WHILE_hexify_string_1
# THEN_while_hexify_string_1
# IF_hexify_string_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_hexify_string_2
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4096
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_hexify_string_2
:ELSE_hexify_string_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_hexify_string_2
JUMP %WHILE_hexify_string_1
:END_WHILE_hexify_string_1
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function process_string
:FUNCTION_process_string
# Defining local i
PUSH_eax	#i
# FOR_initialization_process_string_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_process_string_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_process_string_0

JUMP %FOR_THEN_process_string_0

:FOR_ITER_process_string_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_process_string_0

:FOR_THEN_process_string_0

# IF_process_string_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_process_string_1
# IF_process_string_2
LOAD_IMMEDIATE_eax %39
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_string_2
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_process_string_2
:ELSE_process_string_2
# IF_process_string_3
LOAD_IMMEDIATE_eax %34
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_string_3
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_hexify_string
POP_ebx	# _process_expression_locals
JUMP %_END_IF_process_string_3
:ELSE_process_string_3
:_END_IF_process_string_3
:_END_IF_process_string_2
JUMP %_END_IF_process_string_1
:ELSE_process_string_1
:_END_IF_process_string_1
JUMP %FOR_ITER_process_string_0

:FOR_END_process_string_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function preserve_other
:FUNCTION_preserve_other
# Defining local i
PUSH_eax	#i
# FOR_initialization_preserve_other_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_preserve_other_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_preserve_other_0

JUMP %FOR_THEN_preserve_other_0

:FOR_ITER_preserve_other_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_preserve_other_0

:FOR_THEN_preserve_other_0

# IF_preserve_other_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_preserve_other_1
# Defining local c
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#c
# IF_preserve_other_2
LOAD_IMMEDIATE_eax %33
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %64
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %36
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %37
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %38
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_preserve_other_2
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_preserve_other_2
:ELSE_preserve_other_2
LOAD_IMMEDIATE_eax &STRING_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_9
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
:_END_IF_preserve_other_2
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_preserve_other_1
:ELSE_preserve_other_1
:_END_IF_preserve_other_1
JUMP %FOR_ITER_preserve_other_0

:FOR_END_preserve_other_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function bound_values
:FUNCTION_bound_values
# IF_bound_values_0

LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_bound_values_0

LOAD_IMMEDIATE_eax &STRING_10
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_11
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_bound_values_0

:ELSE_bound_values_0

:_END_IF_bound_values_0

RETURN
# Defining function range_check
:FUNCTION_range_check
# IF_range_check_0

LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_0

RETURN
JUMP %_END_IF_range_check_0

:ELSE_range_check_0

# IF_range_check_1
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8388608
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %16777216
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_bound_values
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
RETURN
JUMP %_END_IF_range_check_1
:ELSE_range_check_1
# IF_range_check_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_2
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32768
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %65535
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_bound_values
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
RETURN
JUMP %_END_IF_range_check_2
:ELSE_range_check_2
# IF_range_check_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_range_check_3
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %128
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %255
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_bound_values
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
RETURN
JUMP %_END_IF_range_check_3
:ELSE_range_check_3
:_END_IF_range_check_3
:_END_IF_range_check_2
:_END_IF_range_check_1
:_END_IF_range_check_0

LOAD_IMMEDIATE_eax &STRING_13
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
RETURN
# Defining function reverseBitOrder
:FUNCTION_reverseBitOrder
# IF_reverseBitOrder_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_reverseBitOrder_0

RETURN
JUMP %_END_IF_reverseBitOrder_0

:ELSE_reverseBitOrder_0

:_END_IF_reverseBitOrder_0

# IF_reverseBitOrder_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_reverseBitOrder_1
RETURN
JUMP %_END_IF_reverseBitOrder_1
:ELSE_reverseBitOrder_1
:_END_IF_reverseBitOrder_1
# Defining local hold
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#hold
# IF_reverseBitOrder_2
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_reverseBitOrder_2
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_reverseBitOrder
POP_ebx	# _process_expression_locals
JUMP %_END_IF_reverseBitOrder_2
:ELSE_reverseBitOrder_2
# IF_reverseBitOrder_3
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_reverseBitOrder_3
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_reverseBitOrder
POP_ebx	# _process_expression_locals
JUMP %_END_IF_reverseBitOrder_3
:ELSE_reverseBitOrder_3
# IF_reverseBitOrder_4
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_reverseBitOrder_4
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %7
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %7
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %6
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %6
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %5
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %5
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_reverseBitOrder
POP_ebx	# _process_expression_locals
JUMP %_END_IF_reverseBitOrder_4
:ELSE_reverseBitOrder_4
:_END_IF_reverseBitOrder_4
:_END_IF_reverseBitOrder_3
:_END_IF_reverseBitOrder_2
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function LittleEndian
:FUNCTION_LittleEndian
# Defining local end
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#end
# Defining local c
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#c
:WHILE_LittleEndian_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_LittleEndian_0

# THEN_while_LittleEndian_0

LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_LittleEndian_0

:END_WHILE_LittleEndian_0

# Defining local hold
PUSH_eax	#hold
# FOR_initialization_LittleEndian_1
LOAD_EFFECTIVE_ADDRESS %8
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_LittleEndian_1
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %FOR_END_LittleEndian_1
JUMP %FOR_THEN_LittleEndian_1
:FOR_ITER_LittleEndian_1
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_LittleEndian_1
:FOR_THEN_LittleEndian_1
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %8
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_ITER_LittleEndian_1
:FOR_END_LittleEndian_1
# IF_LittleEndian_2
LOAD_IMMEDIATE_eax &GLOBAL_BigBitEndian
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_LittleEndian_2
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_reverseBitOrder
POP_ebx	# _process_expression_locals
JUMP %_END_IF_LittleEndian_2
:ELSE_LittleEndian_2
:_END_IF_LittleEndian_2
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function stringify
:FUNCTION_stringify
# Defining local i
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#i
# IF_stringify_0

LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_stringify_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_process_expression2
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_stringify
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_stringify_0

:ELSE_stringify_0

:_END_IF_stringify_0

LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_hex2char
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
COPY_eax_to_ecx
POP_eax
SAR_eax_cl
POP_ebx	# _return_result_locals
RETURN
# Defining function express_number
:FUNCTION_express_number
# Defining local ch
LOAD_IMMEDIATE_eax %42
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#ch
# Defining local size
PUSH_eax	#size
# Defining local number_of_bytes
PUSH_eax	#number_of_bytes
# Defining local shift
PUSH_eax	#shift
# IF_express_number_0

LOAD_IMMEDIATE_eax %33
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_express_number_0

LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %24
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0xFF
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_express_number_0

:ELSE_express_number_0

# IF_express_number_1
LOAD_IMMEDIATE_eax %64
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_express_number_1
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %24
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0xFFFF
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_express_number_1
:ELSE_express_number_1
# IF_express_number_2
LOAD_IMMEDIATE_eax %37
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_express_number_2
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %24
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %28
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0xFFFFFFFF
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_express_number_2
:ELSE_express_number_2
LOAD_IMMEDIATE_eax &STRING_14
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_15
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
:_END_IF_express_number_2
:_END_IF_express_number_1
:_END_IF_express_number_0

LOAD_EFFECTIVE_ADDRESS %24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_range_check
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
# IF_express_number_3
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_express_number_3
LOAD_EFFECTIVE_ADDRESS %8
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_express_number_3
:ELSE_express_number_3
# IF_express_number_4
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_express_number_4
LOAD_EFFECTIVE_ADDRESS %8
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_express_number_4
:ELSE_express_number_4
# IF_express_number_5
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_express_number_5
LOAD_EFFECTIVE_ADDRESS %8
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_express_number_5
:ELSE_express_number_5
LOAD_IMMEDIATE_eax &STRING_16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
:_END_IF_express_number_5
:_END_IF_express_number_4
:_END_IF_express_number_3
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_EFFECTIVE_ADDRESS %36
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_stringify
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
# IF_express_number_6
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
LOAD_INTEGER
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_express_number_6
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_LittleEndian
POP_ebx	# _process_expression_locals
JUMP %_END_IF_express_number_6
:ELSE_express_number_6
# IF_express_number_7
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_BigBitEndian
LOAD_INTEGER
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_express_number_7
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_reverseBitOrder
POP_ebx	# _process_expression_locals
JUMP %_END_IF_express_number_7
:ELSE_express_number_7
:_END_IF_express_number_7
:_END_IF_express_number_6
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function eval_immediates
:FUNCTION_eval_immediates
# Defining local i
PUSH_eax	#i
# FOR_initialization_eval_immediates_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_eval_immediates_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_eval_immediates_0

JUMP %FOR_THEN_eval_immediates_0

:FOR_ITER_eval_immediates_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_eval_immediates_0

:FOR_THEN_eval_immediates_0

# IF_eval_immediates_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_eval_immediates_1
# Defining local value
PUSH_eax	#value
# IF_eval_immediates_2
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_eval_immediates_2
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_numerate_string
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_eval_immediates_3
LOAD_IMMEDIATE_eax %48
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_eval_immediates_3
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_express_number
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_eval_immediates_3
:ELSE_eval_immediates_3
:_END_IF_eval_immediates_3
JUMP %_END_IF_eval_immediates_2
:ELSE_eval_immediates_2
# IF_eval_immediates_4
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_eval_immediates_4
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_numerate_string
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_eval_immediates_5
LOAD_IMMEDIATE_eax %48
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_eval_immediates_5
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %64
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_express_number
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_eval_immediates_5
:ELSE_eval_immediates_5
:_END_IF_eval_immediates_5
JUMP %_END_IF_eval_immediates_4
:ELSE_eval_immediates_4
LOAD_IMMEDIATE_eax &STRING_17
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
:_END_IF_eval_immediates_4
:_END_IF_eval_immediates_2
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_eval_immediates_1
:ELSE_eval_immediates_1
:_END_IF_eval_immediates_1
JUMP %FOR_ITER_eval_immediates_0

:FOR_END_eval_immediates_0

POP_ebx	# _recursive_statement_locals
RETURN
# Defining function print_hex
:FUNCTION_print_hex
# Defining local i
PUSH_eax	#i
# FOR_initialization_print_hex_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_print_hex_0

LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_print_hex_0

JUMP %FOR_THEN_print_hex_0

:FOR_ITER_print_hex_0

LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_print_hex_0

:FOR_THEN_print_hex_0

# IF_print_hex_1
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_print_hex_1
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_destination_file
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_destination_file
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
JUMP %_END_IF_print_hex_1
:ELSE_print_hex_1
:_END_IF_print_hex_1
JUMP %FOR_ITER_print_hex_0

:FOR_END_print_hex_0

LOAD_IMMEDIATE_eax %10
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_destination_file
LOAD_INTEGER
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function main
:FUNCTION_main
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local head
LOAD_IMMEDIATE_eax %0
PUSH_eax	#head
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_destination_file
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_BigBitEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local option_index
LOAD_IMMEDIATE_eax %1
PUSH_eax	#option_index
:WHILE_main_0

LOAD_EFFECTIVE_ADDRESS %0

LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_main_0

# THEN_while_main_0

# IF_main_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_1
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_1
:ELSE_main_1
# IF_main_2
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_18
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
TEST
JUMP_EQ %ELSE_main_2
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_2
:ELSE_main_2
# IF_main_3
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_19
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
TEST
JUMP_EQ %ELSE_main_3
LOAD_IMMEDIATE_eax &GLOBAL_BigEndian
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_3
:ELSE_main_3
# IF_main_4
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_20
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_21
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_4
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_numerate_string
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_4
:ELSE_main_4
# IF_main_5
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_22
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_23
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_5
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_5
:ELSE_main_5
# IF_main_6
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_24
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_25
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_6
LOAD_IMMEDIATE_eax &STRING_26
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_27
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_main_6
:ELSE_main_6
# IF_main_7
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_28
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_29
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_7
LOAD_IMMEDIATE_eax &GLOBAL_source_file
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_30
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_8
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_source_file
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_8
LOAD_IMMEDIATE_eax &STRING_31
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_32
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_main_8
:ELSE_main_8
:_END_IF_main_8
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_Tokenize_Line
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_7
:ELSE_main_7
# IF_main_9
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_33
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_34
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_9
LOAD_IMMEDIATE_eax &GLOBAL_destination_file
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_35
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_10
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_destination_file
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_10
LOAD_IMMEDIATE_eax &STRING_36
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax &STRING_37
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_main_10
:ELSE_main_10
:_END_IF_main_10
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_9
:ELSE_main_9
# IF_main_11
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_38
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_39
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_11
LOAD_IMMEDIATE_eax &GLOBAL_ByteMode
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %0

PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_11
:ELSE_main_11
# IF_main_12
LOAD_EFFECTIVE_ADDRESS %16
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_40
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %20
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_41
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_12
LOAD_IMMEDIATE_eax &STRING_42
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_main_12
:ELSE_main_12
LOAD_IMMEDIATE_eax &STRING_43
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
:_END_IF_main_12
:_END_IF_main_11
:_END_IF_main_9
:_END_IF_main_7
:_END_IF_main_6
:_END_IF_main_5
:_END_IF_main_4
:_END_IF_main_3
:_END_IF_main_2
:_END_IF_main_1
JUMP %WHILE_main_0

:END_WHILE_main_0

# IF_main_13
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_13
LOAD_IMMEDIATE_eax &STRING_44
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
JUMP %_END_IF_main_13
:ELSE_main_13
:_END_IF_main_13
LOAD_EFFECTIVE_ADDRESS %4
PUSH_eax	#_common_recursion
LOAD_EFFECTIVE_ADDRESS %8
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_reverse_list
POP_ebx	# _process_expression_locals
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_identify_macros
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_line_macro
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_process_string
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_eval_immediates
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_preserve_other
POP_ebx	# _process_expression_locals
LOAD_EFFECTIVE_ADDRESS %4
LOAD_INTEGER
PUSH_eax	#_process_expression1
CALL_IMMEDIATE %FUNCTION_print_hex
POP_ebx	# _process_expression_locals
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN

:ELF_data

# Program global variables

:GLOBAL_source_file
NOP
:GLOBAL_destination_file
NOP
:GLOBAL_BigEndian
NOP
:GLOBAL_BigBitEndian
NOP
:GLOBAL_ByteMode
NOP
:GLOBAL_Architecture
NOP

# Program strings

:STRING_0

"calloc failed.
"
:STRING_1
"Exhusted available memory
"
:STRING_2
"Exhusted available memory
"
:STRING_3
' 55 6E 6D 61 74 63 68 65 64 20 5C 22 21 0A 00'
:STRING_4
"String: "
:STRING_5
" exceeds max string size
"
:STRING_6
"DEFINE"
:STRING_7
"0123456789ABCDEF"
:STRING_8
"Recieved invalid other; "
:STRING_9
"
"
:STRING_10
"A displacement of "
:STRING_11
" does not fit in "
:STRING_12
" bytes
"
:STRING_13
"Recieved an invalid number of bytes in range_check
"
:STRING_14
"Given symbol "
:STRING_15
" to express immediate value "
:STRING_16
"Got invalid ByteMode in express_number
"
:STRING_17
"Unknown architecture recieved in eval_immediates
"
:STRING_18
"--BigEndian"
:STRING_19
"--LittleEndian"
:STRING_20
"-A"
:STRING_21
"--Architecture"
:STRING_22
"-b"
:STRING_23
"--binary"
:STRING_24
"-h"
:STRING_25
"--help"
:STRING_26
"Usage: "
:STRING_27
" -f FILENAME1 {-f FILENAME2} (--BigEndian|--LittleEndian) [--BaseAddress 12345] [--Architecture 12345]
Architecture 0: Knight; 1: x86; 2: AMD64"
:STRING_28
"-f"
:STRING_29
"--file"
:STRING_30
"r"
:STRING_31
"The file: "
:STRING_32
" can not be opened!
"
:STRING_33
"-o"
:STRING_34
"--output"
:STRING_35
"w"
:STRING_36
"The file: "
:STRING_37
" can not be opened!
"
:STRING_38
"-O"
:STRING_39
"--octal"
:STRING_40
"-V"
:STRING_41
"--version"
:STRING_42
"M1 0.3
"
:STRING_43
"Unknown option
"
:STRING_44
"Either no input files were given or they were empty
"
