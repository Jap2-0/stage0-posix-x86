# This is a generated file from M2-Planet and will be replaced by a handwritten one in the fut
# DO NOT TRUST THIS FILE!!!!

# Core program
# Defining function fgetc
:FUNCTION_fgetc
LOAD_IMMEDIATE_eax %3
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
PUSH_ebx
COPY_esp_to_ecx
LOAD_IMMEDIATE_edx %1
INT_80
TEST
POP_eax
JUMP_NE8 !FUNCTION_fgetc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_fgetc_Done
RETURN
# Defining function fputc
:FUNCTION_fputc
LOAD_IMMEDIATE_eax %4
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_IMMEDIATE_edx %1
INT_80
RETURN
# Defining function open
:FUNCTION_open
LOAD_EFFECTIVE_ADDRESS_ebx %12
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_INTEGER_ecx
LOAD_EFFECTIVE_ADDRESS_edx %4
LOAD_INTEGER_edx
LOAD_IMMEDIATE_eax %5
INT_80
RETURN
# Defining function fopen
:FUNCTION_fopen
# Defining local f
PUSH_eax	#f
# IF_fopen_0
LOAD_IMMEDIATE_eax %119
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %577
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %384
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_fopen_0
:ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_fopen_0
# IF_fopen_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_fopen_1
:ELSE_fopen_1
:_END_IF_fopen_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function close
:FUNCTION_close
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_IMMEDIATE_eax %6
INT_80
RETURN
# Defining function fclose
:FUNCTION_fclose
# Defining local error
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_close
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#error
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function malloc
:FUNCTION_malloc
LOAD_ESP_IMMEDIATE_into_eax %4
PUSH_eax
LOAD_IMMEDIATE_eax %45
LOAD_IMMEDIATE_ebx %0
INT_80
POP_ebx
ADD_eax_to_ebx
PUSH_eax
PUSH_ebx
LOAD_IMMEDIATE_eax %45
INT_80
POP_ebx
CMP
POP_eax
JUMP_EQ8 !FUNCTION_malloc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_malloc_Done
RETURN
# Defining function memset
:FUNCTION_memset
# Defining local s
PUSH_eax	#s
# FOR_initialization_memset_0
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_memset_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %FOR_END_memset_0
JUMP %FOR_THEN_memset_0
:FOR_ITER_memset_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_memset_0
:FOR_THEN_memset_0
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_ITER_memset_0
:FOR_END_memset_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function calloc
:FUNCTION_calloc
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_malloc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_memset
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function free
:FUNCTION_free
RETURN
# Defining function exit
:FUNCTION_exit
POP_ebx
POP_ebx
LOAD_IMMEDIATE_eax %1
INT_80
RETURN
# Defining function match
:FUNCTION_match
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#i
:DO_match_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_match_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_match_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_match_1
:ELSE_match_1
:_END_IF_match_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_NE %DO_match_0
:DO_END_match_0
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
RETURN
# Defining function in_set
:FUNCTION_in_set
:WHILE_in_set_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_in_set_0
# THEN_while_in_set_0
# IF_in_set_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_in_set_1
LOAD_IMMEDIATE_eax %1
RETURN
JUMP %_END_IF_in_set_1
:ELSE_in_set_1
:_END_IF_in_set_1
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_in_set_0
:END_WHILE_in_set_0
LOAD_IMMEDIATE_eax %0
RETURN
# Defining function numerate_number
:FUNCTION_numerate_number
# Defining local result
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#result
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
# IF_numerate_number_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_number_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_numerate_number_0
:ELSE_numerate_number_0
:_END_IF_numerate_number_0
# IF_numerate_number_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_number_1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %45
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_numerate_number_1
:ELSE_numerate_number_1
:_END_IF_numerate_number_1
# Defining local divisor
LOAD_IMMEDIATE_eax %0x3B9ACA00
PUSH_eax	#divisor
:WHILE_numerate_number_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_numerate_number_2
# THEN_while_numerate_number_2
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_numerate_number_2
:END_WHILE_numerate_number_2
:WHILE_numerate_number_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %END_WHILE_numerate_number_3
# THEN_while_numerate_number_3
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_numerate_number_3
:END_WHILE_numerate_number_3
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function char2hex
:FUNCTION_char2hex
# IF_char2hex_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %57
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2hex_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2hex_0
:ELSE_char2hex_0
# IF_char2hex_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %97
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %102
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2hex_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %87
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2hex_1
:ELSE_char2hex_1
# IF_char2hex_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %65
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %70
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2hex_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %55
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2hex_2
:ELSE_char2hex_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_char2hex_2
:_END_IF_char2hex_1
:_END_IF_char2hex_0
RETURN
# Defining function hex2char
:FUNCTION_hex2char
# IF_hex2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %9
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_hex2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_hex2char_0
:ELSE_hex2char_0
# IF_hex2char_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %15
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_hex2char_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %55
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_hex2char_1
:ELSE_hex2char_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_hex2char_1
:_END_IF_hex2char_0
RETURN
# Defining function char2dec
:FUNCTION_char2dec
# IF_char2dec_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %57
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_char2dec_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
JUMP %_END_IF_char2dec_0
:ELSE_char2dec_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_char2dec_0
RETURN
# Defining function dec2char
:FUNCTION_dec2char
# IF_dec2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %9
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_dec2char_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
ADD_ebx_to_eax
RETURN
JUMP %_END_IF_dec2char_0
:ELSE_dec2char_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
RETURN
:_END_IF_dec2char_0
RETURN
# Defining function index_number
:FUNCTION_index_number
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
:WHILE_index_number_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_index_number_0
# THEN_while_index_number_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_index_number_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_index_number_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_index_number_1
:ELSE_index_number_1
:_END_IF_index_number_1
JUMP %WHILE_index_number_0
:END_WHILE_index_number_0
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function toupper
:FUNCTION_toupper
# IF_toupper_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_toupper_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_toupper_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0xDF
POP_ebx	# _common_recursion
AND_eax_ebx
RETURN
JUMP %_END_IF_toupper_0
:ELSE_toupper_0
:_END_IF_toupper_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
# Defining function set_reader
:FUNCTION_set_reader
# Defining local n
LOAD_IMMEDIATE_eax %0
PUSH_eax	#n
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
# Defining local hold
PUSH_eax	#hold
# Defining local negative_p
LOAD_IMMEDIATE_eax %0
PUSH_eax	#negative_p
# IF_set_reader_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %45
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_set_reader_0
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_set_reader_0
:ELSE_set_reader_0
:_END_IF_set_reader_0
:WHILE_set_reader_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %END_WHILE_set_reader_1
# THEN_while_set_reader_1
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-28
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_toupper
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_index_number
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_set_reader_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_set_reader_2
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_set_reader_2
:ELSE_set_reader_2
:_END_IF_set_reader_2
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_set_reader_1
:END_WHILE_set_reader_1
# IF_set_reader_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_set_reader_3
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_set_reader_3
:ELSE_set_reader_3
:_END_IF_set_reader_3
# IF_set_reader_4
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_set_reader_4
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_set_reader_4
:ELSE_set_reader_4
:_END_IF_set_reader_4
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function numerate_string
:FUNCTION_numerate_string
# IF_numerate_string_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_0
LOAD_IMMEDIATE_eax %0
RETURN
JUMP %_END_IF_numerate_string_0
:ELSE_numerate_string_0
# IF_numerate_string_1
LOAD_IMMEDIATE_eax %48
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %98
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_numerate_string_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_numerate_string_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_set_reader
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_numerate_string_1
:ELSE_numerate_string_1
# IF_numerate_string_3
LOAD_IMMEDIATE_eax %48
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %120
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_numerate_string_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_numerate_string_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %16
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_set_reader
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_numerate_string_3
:ELSE_numerate_string_3
# IF_numerate_string_5
LOAD_IMMEDIATE_eax %48
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_numerate_string_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_numerate_string_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_set_reader
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_numerate_string_5
:ELSE_numerate_string_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_numerate_string_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_set_reader
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
:_END_IF_numerate_string_5
:_END_IF_numerate_string_3
:_END_IF_numerate_string_1
:_END_IF_numerate_string_0
RETURN
# Defining function file_print
:FUNCTION_file_print
:WHILE_file_print_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_file_print_0
# THEN_while_file_print_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_file_print_0
:END_WHILE_file_print_0
RETURN
# Defining function number_to_hex
:FUNCTION_number_to_hex
# Defining local result
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAL_eax_cl
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#result
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
# Defining local divisor
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAL_eax_cl
PUSH_eax	#divisor
:WHILE_number_to_hex_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_number_to_hex_0
# THEN_while_number_to_hex_0
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0xF
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_hex2char
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_number_to_hex_0
:END_WHILE_number_to_hex_0
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function copy_string
:FUNCTION_copy_string
:WHILE_copy_string_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_copy_string_0
# THEN_while_copy_string_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_copy_string_0
:END_WHILE_copy_string_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
# Defining function postpend_char
:FUNCTION_postpend_char
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
# Defining local hold
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#hold
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function prepend_char
:FUNCTION_prepend_char
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function prepend_string
:FUNCTION_prepend_string
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function string_length
:FUNCTION_string_length
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
:WHILE_string_length_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_string_length_0
# THEN_while_string_length_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_string_length_0
:END_WHILE_string_length_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function clearWhiteSpace
:FUNCTION_clearWhiteSpace
# IF_clearWhiteSpace_0
LOAD_IMMEDIATE_eax %32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %9
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_clearWhiteSpace_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_clearWhiteSpace
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_clearWhiteSpace_0
:ELSE_clearWhiteSpace_0
# IF_clearWhiteSpace_1
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_clearWhiteSpace_1
LOAD_IMMEDIATE_eax &GLOBAL_line
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_line
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_clearWhiteSpace
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_clearWhiteSpace_1
:ELSE_clearWhiteSpace_1
:_END_IF_clearWhiteSpace_1
:_END_IF_clearWhiteSpace_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
# Defining function consume_byte
:FUNCTION_consume_byte
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_string_index
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function preserve_string
:FUNCTION_preserve_string
# Defining local frequent
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#frequent
# Defining local escape
LOAD_IMMEDIATE_eax %0
PUSH_eax	#escape
:DO_preserve_string_0
# IF_preserve_string_1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %92
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_preserve_string_1
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_preserve_string_1
:ELSE_preserve_string_1
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_preserve_string_1
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_byte
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_NE %DO_preserve_string_0
:DO_END_preserve_string_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function fixup_label
:FUNCTION_fixup_label
# Defining local hold
LOAD_IMMEDIATE_eax %58
PUSH_eax	#hold
# Defining local prev
PUSH_eax	#prev
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
:DO_fixup_label_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_NE %DO_fixup_label_0
:DO_END_fixup_label_0
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function preserve_keyword
:FUNCTION_preserve_keyword
:WHILE_preserve_keyword_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %END_WHILE_preserve_keyword_0
# THEN_while_preserve_keyword_0
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_byte
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_preserve_keyword_0
:END_WHILE_preserve_keyword_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
# Defining function purge_macro
:FUNCTION_purge_macro
:WHILE_purge_macro_0
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_purge_macro_0
# THEN_while_purge_macro_0
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_purge_macro_0
:END_WHILE_purge_macro_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
# Defining function reset_hold_string
:FUNCTION_reset_hold_string
# Defining local i
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#i
:WHILE_reset_hold_string_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_reset_hold_string_0
# THEN_while_reset_hold_string_0
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_reset_hold_string_0
:END_WHILE_reset_hold_string_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function get_token
:FUNCTION_get_token
# Defining local current
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %20
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#current
:reset	#C goto label
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_reset_hold_string
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_string_index
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_clearWhiteSpace
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_get_token_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0xFFFFFFFF
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_free
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_get_token_0
:ELSE_get_token_0
# IF_get_token_1
LOAD_IMMEDIATE_eax %35
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_1
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_purge_macro
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %reset
JUMP %_END_IF_get_token_1
:ELSE_get_token_1
# IF_get_token_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_get_token_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_get_token_2
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_get_token_4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_preserve_keyword
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_get_token_5
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fixup_label
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_get_token_5
:ELSE_get_token_5
:_END_IF_get_token_5
JUMP %_END_IF_get_token_2
:ELSE_get_token_2
# IF_get_token_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_get_token_7
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_get_token_6
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_get_token_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_preserve_keyword
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_get_token_6
:ELSE_get_token_6
# IF_get_token_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_get_token_10
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_get_token_9
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_preserve_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_get_token_9
:ELSE_get_token_9
# IF_get_token_11
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %47
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_11
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_byte
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_get_token_12
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %42
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_12
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:WHILE_get_token_13
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %47
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_get_token_13
# THEN_while_get_token_13
:WHILE_get_token_14
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %42
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_get_token_14
# THEN_while_get_token_14
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_get_token_15
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_15
LOAD_IMMEDIATE_eax &GLOBAL_line
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_line
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_get_token_15
:ELSE_get_token_15
:_END_IF_get_token_15
JUMP %WHILE_get_token_14
:END_WHILE_get_token_14
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_get_token_16
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_16
LOAD_IMMEDIATE_eax &GLOBAL_line
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_line
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_get_token_16
:ELSE_get_token_16
:_END_IF_get_token_16
JUMP %WHILE_get_token_13
:END_WHILE_get_token_13
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %reset
JUMP %_END_IF_get_token_12
:ELSE_get_token_12
# IF_get_token_17
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %47
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_get_token_17
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %reset
JUMP %_END_IF_get_token_17
:ELSE_get_token_17
:_END_IF_get_token_17
:_END_IF_get_token_12
JUMP %_END_IF_get_token_11
:ELSE_get_token_11
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_byte
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_get_token_11
:_END_IF_get_token_9
:_END_IF_get_token_6
:_END_IF_get_token_2
:_END_IF_get_token_1
:_END_IF_get_token_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_token
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_token
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_line
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_file
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_token
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function reverse_list
:FUNCTION_reverse_list
# Defining local root
LOAD_IMMEDIATE_eax %0
PUSH_eax	#root
:WHILE_reverse_list_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_reverse_list_0
# THEN_while_reverse_list_0
# Defining local next
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#next
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %WHILE_reverse_list_0
:END_WHILE_reverse_list_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function read_all_tokens
:FUNCTION_read_all_tokens
LOAD_IMMEDIATE_eax &GLOBAL_input
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_line
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_file
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_token
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local ch
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_input
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ch
:WHILE_read_all_tokens_0
LOAD_IMMEDIATE_eax %0xFFFFFFFF
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_read_all_tokens_0
# THEN_while_read_all_tokens_0
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_get_token
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_read_all_tokens_0
:END_WHILE_read_all_tokens_0
LOAD_IMMEDIATE_eax &GLOBAL_token
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function upcase
:FUNCTION_upcase
# IF_upcase_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_upcase_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_upcase_0
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_upcase_0
:ELSE_upcase_0
:_END_IF_upcase_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
# Defining function hexify
:FUNCTION_hexify
# Defining local i
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_char2hex
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#i
# IF_hexify_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_hexify_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_hexify_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_hexify_0
:ELSE_hexify_0
:_END_IF_hexify_0
# IF_hexify_2
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_hexify_2
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAL_eax_cl
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_hexify_2
:ELSE_hexify_2
:_END_IF_hexify_2
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function weird
:FUNCTION_weird
# Defining local c
PUSH_eax	#c
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
:weird_reset	#C goto label
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_weird_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_weird_0
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_weird_0
:ELSE_weird_0
:_END_IF_weird_0
# IF_weird_1
LOAD_IMMEDIATE_eax %92
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_weird_1
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_escape_lookup
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_weird_2
LOAD_IMMEDIATE_eax %120
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_weird_2
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_weird_2
:ELSE_weird_2
:_END_IF_weird_2
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_weird_1
:ELSE_weird_1
:_END_IF_weird_1
# IF_weird_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_weird_4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_weird_3
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_weird_3
:ELSE_weird_3
:_END_IF_weird_3
# IF_weird_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_weird_6
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_weird_5
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_weird_5
:ELSE_weird_5
:_END_IF_weird_5
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %weird_reset
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function escape_lookup
:FUNCTION_escape_lookup
# IF_escape_lookup_0
LOAD_IMMEDIATE_eax %92
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
RETURN
JUMP %_END_IF_escape_lookup_0
:ELSE_escape_lookup_0
:_END_IF_escape_lookup_0
# IF_escape_lookup_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %120
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_1
# Defining local t1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_hexify
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#t1
# Defining local t2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_hexify
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#t2
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_escape_lookup_1
:ELSE_escape_lookup_1
# IF_escape_lookup_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_2
LOAD_IMMEDIATE_eax %0
RETURN
JUMP %_END_IF_escape_lookup_2
:ELSE_escape_lookup_2
# IF_escape_lookup_3
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %116
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_3
LOAD_IMMEDIATE_eax %9
RETURN
JUMP %_END_IF_escape_lookup_3
:ELSE_escape_lookup_3
# IF_escape_lookup_4
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %110
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_4
LOAD_IMMEDIATE_eax %10
RETURN
JUMP %_END_IF_escape_lookup_4
:ELSE_escape_lookup_4
# IF_escape_lookup_5
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %118
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_5
LOAD_IMMEDIATE_eax %11
RETURN
JUMP %_END_IF_escape_lookup_5
:ELSE_escape_lookup_5
# IF_escape_lookup_6
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %102
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_6
LOAD_IMMEDIATE_eax %12
RETURN
JUMP %_END_IF_escape_lookup_6
:ELSE_escape_lookup_6
# IF_escape_lookup_7
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %114
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_7
LOAD_IMMEDIATE_eax %13
RETURN
JUMP %_END_IF_escape_lookup_7
:ELSE_escape_lookup_7
# IF_escape_lookup_8
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %101
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_8
LOAD_IMMEDIATE_eax %27
RETURN
JUMP %_END_IF_escape_lookup_8
:ELSE_escape_lookup_8
# IF_escape_lookup_9
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %34
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_9
LOAD_IMMEDIATE_eax %34
RETURN
JUMP %_END_IF_escape_lookup_9
:ELSE_escape_lookup_9
# IF_escape_lookup_10
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %39
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_10
LOAD_IMMEDIATE_eax %39
RETURN
JUMP %_END_IF_escape_lookup_10
:ELSE_escape_lookup_10
# IF_escape_lookup_11
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %92
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_escape_lookup_11
LOAD_IMMEDIATE_eax %92
RETURN
JUMP %_END_IF_escape_lookup_11
:ELSE_escape_lookup_11
:_END_IF_escape_lookup_11
:_END_IF_escape_lookup_10
:_END_IF_escape_lookup_9
:_END_IF_escape_lookup_8
:_END_IF_escape_lookup_7
:_END_IF_escape_lookup_6
:_END_IF_escape_lookup_5
:_END_IF_escape_lookup_4
:_END_IF_escape_lookup_3
:_END_IF_escape_lookup_2
:_END_IF_escape_lookup_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_escape_lookup_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_escape_lookup_13
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function collect_regular_string
:FUNCTION_collect_regular_string
LOAD_IMMEDIATE_eax &GLOBAL_string_index
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
:collect_regular_string_reset	#C goto label
# IF_collect_regular_string_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %92
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_regular_string_0
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_escape_lookup
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_CHAR
# IF_collect_regular_string_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %120
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_regular_string_1
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_regular_string_1
:ELSE_collect_regular_string_1
:_END_IF_collect_regular_string_1
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_regular_string_0
:ELSE_collect_regular_string_0
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_collect_regular_string_0
LOAD_IMMEDIATE_eax &GLOBAL_string_index
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_collect_regular_string_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_regular_string_2
JUMP %collect_regular_string_reset
JUMP %_END_IF_collect_regular_string_2
:ELSE_collect_regular_string_2
:_END_IF_collect_regular_string_2
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %34
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
STORE_CHAR
# Defining local message
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#message
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_reset_hold_string
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function collect_weird_string
:FUNCTION_collect_weird_string
LOAD_IMMEDIATE_eax &GLOBAL_string_index
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local temp
PUSH_eax	#temp
# Defining local table
LOAD_IMMEDIATE_eax &STRING_collect_weird_string_0
PUSH_eax	#table
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %39
POP_ebx	# _common_recursion
STORE_CHAR
:collect_weird_string_reset	#C goto label
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_escape_lookup
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %15
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
STORE_CHAR
# IF_collect_weird_string_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %92
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_weird_string_1
# IF_collect_weird_string_2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %120
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_weird_string_2
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_weird_string_2
:ELSE_collect_weird_string_2
:_END_IF_collect_weird_string_2
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_weird_string_1
:ELSE_collect_weird_string_1
:_END_IF_collect_weird_string_1
LOAD_IMMEDIATE_eax &GLOBAL_string_index
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_collect_weird_string_3
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_weird_string_3
JUMP %collect_weird_string_reset
JUMP %_END_IF_collect_weird_string_3
:ELSE_collect_weird_string_3
:_END_IF_collect_weird_string_3
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %48
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %39
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
POP_ebx	# _common_recursion
STORE_CHAR
# Defining local hold
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_string_index
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %6
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#hold
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_copy_string
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_reset_hold_string
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function parse_string
:FUNCTION_parse_string
# IF_parse_string_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_weird
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_parse_string_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_collect_weird_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_parse_string_0
:ELSE_parse_string_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_collect_regular_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
:_END_IF_parse_string_0
RETURN
# Defining function initialize_types
:FUNCTION_initialize_types
# IF_initialize_types_0
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_initialize_types_0
LOAD_IMMEDIATE_eax &GLOBAL_register_size
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_initialize_types_0
:ELSE_initialize_types_0
LOAD_IMMEDIATE_eax &GLOBAL_register_size
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_initialize_types_0
LOAD_IMMEDIATE_eax &GLOBAL_global_types
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_2
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local b
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#b
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_3
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_4
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local d
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#d
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_5
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local e
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#e
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_6
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local f
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#f
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_7
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local g
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#g
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_8
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local h
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#h
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_initialize_types_9
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_prim_types
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function lookup_type
:FUNCTION_lookup_type
# Defining local i
PUSH_eax	#i
# FOR_initialization_lookup_type_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_lookup_type_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_lookup_type_0
JUMP %FOR_THEN_lookup_type_0
:FOR_ITER_lookup_type_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_lookup_type_0
:FOR_THEN_lookup_type_0
# IF_lookup_type_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_lookup_type_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_lookup_type_1
:ELSE_lookup_type_1
:_END_IF_lookup_type_1
JUMP %FOR_ITER_lookup_type_0
:FOR_END_lookup_type_0
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
# Defining function lookup_member
:FUNCTION_lookup_member
# Defining local i
PUSH_eax	#i
# FOR_initialization_lookup_member_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_lookup_member_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_lookup_member_0
JUMP %FOR_THEN_lookup_member_0
:FOR_ITER_lookup_member_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_lookup_member_0
:FOR_THEN_lookup_member_0
# IF_lookup_member_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_lookup_member_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_lookup_member_1
:ELSE_lookup_member_1
:_END_IF_lookup_member_1
JUMP %FOR_ITER_lookup_member_0
:FOR_END_lookup_member_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_lookup_member_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_lookup_member_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_lookup_member_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_lookup_member_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function build_member
:FUNCTION_build_member
# Defining local member_type
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_type_name
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#member_type
# Defining local i
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#i
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_build_member_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_build_member_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_build_member_0
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_build_member_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_build_member_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_build_member_0
:ELSE_build_member_0
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_build_member_0
LOAD_IMMEDIATE_eax &GLOBAL_member_size
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function build_union
:FUNCTION_build_union
# Defining local size
LOAD_IMMEDIATE_eax %0
PUSH_eax	#size
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_build_union_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_build_union_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:WHILE_build_union_2
LOAD_IMMEDIATE_eax %125
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_build_union_2
# THEN_while_build_union_2
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_build_member
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_build_union_3
LOAD_IMMEDIATE_eax &GLOBAL_member_size
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_build_union_3
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_member_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_build_union_3
:ELSE_build_union_3
:_END_IF_build_union_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_build_union_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_build_union_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %WHILE_build_union_2
:END_WHILE_build_union_2
LOAD_IMMEDIATE_eax &GLOBAL_member_size
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function create_struct
:FUNCTION_create_struct
# Defining local offset
LOAD_IMMEDIATE_eax %0
PUSH_eax	#offset
LOAD_IMMEDIATE_eax &GLOBAL_member_size
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local head
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#head
# Defining local i
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %28
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#i
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_types
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_create_struct_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_create_struct_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local last
LOAD_IMMEDIATE_eax %0
PUSH_eax	#last
:WHILE_create_struct_2
LOAD_IMMEDIATE_eax %125
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_create_struct_2
# THEN_while_create_struct_2
# IF_create_struct_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_create_struct_4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_create_struct_3
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_build_union
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_create_struct_3
:ELSE_create_struct_3
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_build_member
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_create_struct_3
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_member_size
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_create_struct_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_create_struct_6
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %WHILE_create_struct_2
:END_WHILE_create_struct_2
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_create_struct_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_create_struct_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function type_name
:FUNCTION_type_name
# Defining local structure
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_type_name_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#structure
# IF_type_name_1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_type_name_1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_type_name_1
:ELSE_type_name_1
:_END_IF_type_name_1
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_lookup_type
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
# IF_type_name_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_type_name_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_type_name_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_type_name_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_type_name_2
:ELSE_type_name_2
# IF_type_name_5
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_type_name_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_create_struct
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_type_name_5
:ELSE_type_name_5
:_END_IF_type_name_5
:_END_IF_type_name_2
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:WHILE_type_name_6
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %42
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_type_name_6
# THEN_while_type_name_6
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_type_name_6
:END_WHILE_type_name_6
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function emit
:FUNCTION_emit
# Defining local t
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %20
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#t
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function emit_out
:FUNCTION_emit_out
LOAD_IMMEDIATE_eax &GLOBAL_out
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
RETURN
# Defining function uniqueID
:FUNCTION_uniqueID
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_uniqueID_0
PUSH_eax	#_process_expression1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_uniqueID_1
PUSH_eax	#_process_expression1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
RETURN
# Defining function uniqueID_out
:FUNCTION_uniqueID_out
LOAD_IMMEDIATE_eax &GLOBAL_out
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
RETURN
# Defining function sym_declare
:FUNCTION_sym_declare
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %20
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function sym_lookup
:FUNCTION_sym_lookup
# Defining local i
PUSH_eax	#i
# FOR_initialization_sym_lookup_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_sym_lookup_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_sym_lookup_0
JUMP %FOR_THEN_sym_lookup_0
:FOR_ITER_sym_lookup_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_sym_lookup_0
:FOR_THEN_sym_lookup_0
# IF_sym_lookup_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_sym_lookup_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_sym_lookup_1
:ELSE_sym_lookup_1
:_END_IF_sym_lookup_1
JUMP %FOR_ITER_sym_lookup_0
:FOR_END_sym_lookup_0
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
# Defining function line_error
:FUNCTION_line_error
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_line_error_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_line_error_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function require_match
:FUNCTION_require_match
# IF_require_match_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_require_match_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_require_match_0
:ELSE_require_match_0
:_END_IF_require_match_0
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
RETURN
# Defining function function_call
:FUNCTION_function_call
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_function_call_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local passed
LOAD_IMMEDIATE_eax %0
PUSH_eax	#passed
# IF_function_call_2
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_function_call_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_4
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_2
:ELSE_function_call_2
# IF_function_call_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_6
:ELSE_function_call_6
# IF_function_call_10
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_12
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_10
:ELSE_function_call_10
# IF_function_call_14
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_15
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_16
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_17
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_14
:ELSE_function_call_14
:_END_IF_function_call_14
:_END_IF_function_call_10
:_END_IF_function_call_6
:_END_IF_function_call_2
# IF_function_call_18
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %41
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_function_call_19
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_function_call_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_19
:ELSE_function_call_19
# IF_function_call_21
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_21
:ELSE_function_call_21
# IF_function_call_23
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_23
:ELSE_function_call_23
# IF_function_call_25
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_26
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_25
:ELSE_function_call_25
:_END_IF_function_call_25
:_END_IF_function_call_23
:_END_IF_function_call_21
:_END_IF_function_call_19
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
:WHILE_function_call_27
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %44
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_function_call_27
# THEN_while_function_call_27
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_function_call_28
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_function_call_28
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_29
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_28
:ELSE_function_call_28
# IF_function_call_30
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_30
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_31
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_30
:ELSE_function_call_30
# IF_function_call_32
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_32
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_33
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_32
:ELSE_function_call_32
# IF_function_call_34
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_35
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_34
:ELSE_function_call_34
:_END_IF_function_call_34
:_END_IF_function_call_32
:_END_IF_function_call_30
:_END_IF_function_call_28
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_function_call_27
:END_WHILE_function_call_27
JUMP %_END_IF_function_call_18
:ELSE_function_call_18
:_END_IF_function_call_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_36
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_function_call_37
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_function_call_38
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_38
# IF_function_call_39
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_function_call_39
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_40
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_41
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_42
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_39
:ELSE_function_call_39
# IF_function_call_43
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_43
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_44
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_45
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_46
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_47
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_43
:ELSE_function_call_43
# IF_function_call_48
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_48
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_49
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_50
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_51
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_52
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_48
:ELSE_function_call_48
# IF_function_call_53
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_53
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_54
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_55
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_56
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_57
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_58
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_59
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_60
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_53
:ELSE_function_call_53
:_END_IF_function_call_53
:_END_IF_function_call_48
:_END_IF_function_call_43
:_END_IF_function_call_39
JUMP %_END_IF_function_call_38
:ELSE_function_call_38
# IF_function_call_61
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_61
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_62
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_63
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_64
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_61
:ELSE_function_call_61
# IF_function_call_65
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_65
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_66
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_67
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_68
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_65
:ELSE_function_call_65
# IF_function_call_69
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_69
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_70
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_71
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_72
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_69
:ELSE_function_call_69
# IF_function_call_73
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_73
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_74
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_75
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_76
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_73
:ELSE_function_call_73
# IF_function_call_77
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_77
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_78
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_79
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_80
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_81
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_82
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_77
:ELSE_function_call_77
:_END_IF_function_call_77
:_END_IF_function_call_73
:_END_IF_function_call_69
:_END_IF_function_call_65
:_END_IF_function_call_61
:_END_IF_function_call_38
# FOR_initialization_function_call_83
:FOR_function_call_83
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %FOR_END_function_call_83
JUMP %FOR_THEN_function_call_83
:FOR_ITER_function_call_83
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_function_call_83
:FOR_THEN_function_call_83
# IF_function_call_84
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_function_call_84
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_85
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_84
:ELSE_function_call_84
# IF_function_call_86
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_86
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_87
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_86
:ELSE_function_call_86
# IF_function_call_88
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_88
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_89
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_88
:ELSE_function_call_88
# IF_function_call_90
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_90
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_91
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_90
:ELSE_function_call_90
:_END_IF_function_call_90
:_END_IF_function_call_88
:_END_IF_function_call_86
:_END_IF_function_call_84
JUMP %FOR_ITER_function_call_83
:FOR_END_function_call_83
# IF_function_call_92
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_function_call_92
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_93
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_94
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_92
:ELSE_function_call_92
# IF_function_call_95
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_95
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_96
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_97
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_95
:ELSE_function_call_95
# IF_function_call_98
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_98
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_99
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_100
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_98
:ELSE_function_call_98
# IF_function_call_101
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_call_101
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_102
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_call_103
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_call_101
:ELSE_function_call_101
:_END_IF_function_call_101
:_END_IF_function_call_98
:_END_IF_function_call_95
:_END_IF_function_call_92
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function constant_load
:FUNCTION_constant_load
# IF_constant_load_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_constant_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_constant_load_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_constant_load_0
:ELSE_constant_load_0
# IF_constant_load_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_constant_load_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_constant_load_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_constant_load_2
:ELSE_constant_load_2
# IF_constant_load_4
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_constant_load_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_constant_load_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_constant_load_4
:ELSE_constant_load_4
# IF_constant_load_6
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_constant_load_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_constant_load_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_constant_load_6
:ELSE_constant_load_6
:_END_IF_constant_load_6
:_END_IF_constant_load_4
:_END_IF_constant_load_2
:_END_IF_constant_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_constant_load_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function variable_load
:FUNCTION_variable_load
# IF_variable_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_1
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_variable_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_function_call
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_variable_load_0
:ELSE_variable_load_0
:_END_IF_variable_load_0
LOAD_IMMEDIATE_eax &GLOBAL_current_target
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_variable_load_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_variable_load_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_4
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_3
:ELSE_variable_load_3
# IF_variable_load_5
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_6
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_5
:ELSE_variable_load_5
# IF_variable_load_7
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_7
:ELSE_variable_load_7
# IF_variable_load_9
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_9
:ELSE_variable_load_9
:_END_IF_variable_load_9
:_END_IF_variable_load_7
:_END_IF_variable_load_5
:_END_IF_variable_load_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_variable_load_11
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_12
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_11
:ELSE_variable_load_11
:_END_IF_variable_load_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_variable_load_14
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Address_of
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_14
RETURN
JUMP %_END_IF_variable_load_14
:ELSE_variable_load_14
:_END_IF_variable_load_14
# IF_variable_load_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_variable_load_15
RETURN
JUMP %_END_IF_variable_load_15
:ELSE_variable_load_15
:_END_IF_variable_load_15
# IF_variable_load_17
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_variable_load_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_17
:ELSE_variable_load_17
# IF_variable_load_19
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_19
:ELSE_variable_load_19
# IF_variable_load_21
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_21
:ELSE_variable_load_21
# IF_variable_load_23
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_variable_load_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_variable_load_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_variable_load_23
:ELSE_variable_load_23
:_END_IF_variable_load_23
:_END_IF_variable_load_21
:_END_IF_variable_load_19
:_END_IF_variable_load_17
RETURN
# Defining function function_load
:FUNCTION_function_load
# IF_function_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_function_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_function_call
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
JUMP %_END_IF_function_load_0
:ELSE_function_load_0
:_END_IF_function_load_0
# IF_function_load_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_load_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_load_2
:ELSE_function_load_2
# IF_function_load_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_load_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_load_4
:ELSE_function_load_4
# IF_function_load_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_load_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_load_6
:ELSE_function_load_6
# IF_function_load_8
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_load_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_load_8
:ELSE_function_load_8
# IF_function_load_10
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_function_load_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_function_load_10
:ELSE_function_load_10
:_END_IF_function_load_10
:_END_IF_function_load_8
:_END_IF_function_load_6
:_END_IF_function_load_4
:_END_IF_function_load_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_function_load_12
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function global_load
:FUNCTION_global_load
LOAD_IMMEDIATE_eax &GLOBAL_current_target
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_global_load_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_0
:ELSE_global_load_0
# IF_global_load_2
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_2
:ELSE_global_load_2
# IF_global_load_4
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_4
:ELSE_global_load_4
# IF_global_load_6
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_6
:ELSE_global_load_6
# IF_global_load_8
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_8
:ELSE_global_load_8
:_END_IF_global_load_8
:_END_IF_global_load_6
:_END_IF_global_load_4
:_END_IF_global_load_2
:_END_IF_global_load_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_global_load_11
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_global_load_11
# IF_global_load_13
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_global_load_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_14
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_13
:ELSE_global_load_13
# IF_global_load_15
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_16
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_15
:ELSE_global_load_15
# IF_global_load_17
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_17
:ELSE_global_load_17
# IF_global_load_19
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_global_load_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_global_load_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_global_load_19
:ELSE_global_load_19
:_END_IF_global_load_19
:_END_IF_global_load_17
:_END_IF_global_load_15
:_END_IF_global_load_13
JUMP %_END_IF_global_load_11
:ELSE_global_load_11
:_END_IF_global_load_11
RETURN
# Defining function primary_expr_failure
:FUNCTION_primary_expr_failure
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_failure_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_failure_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function primary_expr_string
:FUNCTION_primary_expr_string
# Defining local number_string
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#number_string
LOAD_IMMEDIATE_eax &GLOBAL_current_count
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_primary_expr_string_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_string_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_string_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_string_0
:ELSE_primary_expr_string_0
# IF_primary_expr_string_2
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_string_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_string_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_string_2
:ELSE_primary_expr_string_2
# IF_primary_expr_string_4
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_string_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_string_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_string_4
:ELSE_primary_expr_string_4
# IF_primary_expr_string_6
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_string_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_string_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_string_6
:ELSE_primary_expr_string_6
# IF_primary_expr_string_8
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_string_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_string_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_string_8
:ELSE_primary_expr_string_8
:_END_IF_primary_expr_string_8
:_END_IF_primary_expr_string_6
:_END_IF_primary_expr_string_4
:_END_IF_primary_expr_string_2
:_END_IF_primary_expr_string_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_string_10
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_parse_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function primary_expr_char
:FUNCTION_primary_expr_char
# IF_primary_expr_char_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_primary_expr_char_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_char_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_char_0
:ELSE_primary_expr_char_0
# IF_primary_expr_char_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_char_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_char_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_char_2
:ELSE_primary_expr_char_2
# IF_primary_expr_char_4
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_char_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_char_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_char_4
:ELSE_primary_expr_char_4
# IF_primary_expr_char_6
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_char_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_char_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_char_6
:ELSE_primary_expr_char_6
:_END_IF_primary_expr_char_6
:_END_IF_primary_expr_char_4
:_END_IF_primary_expr_char_2
:_END_IF_primary_expr_char_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_escape_lookup
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_primary_expr_char_8
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_char_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_char_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_char_8
:ELSE_primary_expr_char_8
:_END_IF_primary_expr_char_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_char_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
RETURN
# Defining function primary_expr_number
:FUNCTION_primary_expr_number
# IF_primary_expr_number_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_primary_expr_number_0
# Defining local size
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#size
# IF_primary_expr_number_1
LOAD_IMMEDIATE_eax %32768
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %32768
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_primary_expr_number_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_2
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_number_1
:ELSE_primary_expr_number_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_number_to_hex
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_4
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_primary_expr_number_1
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_primary_expr_number_0
:ELSE_primary_expr_number_0
# IF_primary_expr_number_5
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_number_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_6
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_number_5
:ELSE_primary_expr_number_5
# IF_primary_expr_number_7
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_number_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_number_7
:ELSE_primary_expr_number_7
# IF_primary_expr_number_9
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_number_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_number_9
:ELSE_primary_expr_number_9
:_END_IF_primary_expr_number_9
:_END_IF_primary_expr_number_7
:_END_IF_primary_expr_number_5
:_END_IF_primary_expr_number_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_number_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
RETURN
# Defining function primary_expr_variable
:FUNCTION_primary_expr_variable
# Defining local s
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#s
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_constant_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_lookup
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
# IF_primary_expr_variable_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_variable_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_constant_load
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_primary_expr_variable_0
:ELSE_primary_expr_variable_0
:_END_IF_primary_expr_variable_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_lookup
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_primary_expr_variable_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_variable_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_variable_load
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_primary_expr_variable_1
:ELSE_primary_expr_variable_1
:_END_IF_primary_expr_variable_1
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_lookup
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_primary_expr_variable_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_variable_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_variable_load
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_primary_expr_variable_2
:ELSE_primary_expr_variable_2
:_END_IF_primary_expr_variable_2
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_function_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_lookup
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_primary_expr_variable_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_variable_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_function_load
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_primary_expr_variable_3
:ELSE_primary_expr_variable_3
:_END_IF_primary_expr_variable_3
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_symbol_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_lookup
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_primary_expr_variable_4
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_variable_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_global_load
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_primary_expr_variable_4
:ELSE_primary_expr_variable_4
:_END_IF_primary_expr_variable_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_variable_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function promote_type
:FUNCTION_promote_type
# IF_promote_type_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_promote_type_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
RETURN
JUMP %_END_IF_promote_type_0
:ELSE_promote_type_0
:_END_IF_promote_type_0
# IF_promote_type_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_promote_type_1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
RETURN
JUMP %_END_IF_promote_type_1
:ELSE_promote_type_1
:_END_IF_promote_type_1
# Defining local i
PUSH_eax	#i
# FOR_initialization_promote_type_2
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_types
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_promote_type_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_promote_type_2
JUMP %FOR_THEN_promote_type_2
:FOR_ITER_promote_type_2
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_promote_type_2
:FOR_THEN_promote_type_2
# IF_promote_type_3
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_promote_type_3
JUMP %FOR_END_promote_type_2
JUMP %_END_IF_promote_type_3
:ELSE_promote_type_3
:_END_IF_promote_type_3
# IF_promote_type_4
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_promote_type_4
JUMP %FOR_END_promote_type_2
JUMP %_END_IF_promote_type_4
:ELSE_promote_type_4
:_END_IF_promote_type_4
# IF_promote_type_5
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_promote_type_5
JUMP %FOR_END_promote_type_2
JUMP %_END_IF_promote_type_5
:ELSE_promote_type_5
:_END_IF_promote_type_5
# IF_promote_type_6
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_promote_type_6
JUMP %FOR_END_promote_type_2
JUMP %_END_IF_promote_type_6
:ELSE_promote_type_6
:_END_IF_promote_type_6
JUMP %FOR_ITER_promote_type_2
:FOR_END_promote_type_2
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function common_recursion
:FUNCTION_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_last_type
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_common_recursion_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_common_recursion_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_0
:ELSE_common_recursion_0
# IF_common_recursion_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_common_recursion_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_2
:ELSE_common_recursion_2
# IF_common_recursion_4
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_common_recursion_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_4
:ELSE_common_recursion_4
# IF_common_recursion_6
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_common_recursion_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_6
:ELSE_common_recursion_6
:_END_IF_common_recursion_6
:_END_IF_common_recursion_4
:_END_IF_common_recursion_2
:_END_IF_common_recursion_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
COPY_edi_to_ebp
CALL_eax
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_current_target
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_last_type
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_promote_type
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_common_recursion_8
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_common_recursion_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_8
:ELSE_common_recursion_8
# IF_common_recursion_10
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_common_recursion_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_10
:ELSE_common_recursion_10
# IF_common_recursion_12
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_common_recursion_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_12
:ELSE_common_recursion_12
# IF_common_recursion_14
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_common_recursion_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_common_recursion_15
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_common_recursion_14
:ELSE_common_recursion_14
:_END_IF_common_recursion_14
:_END_IF_common_recursion_12
:_END_IF_common_recursion_10
:_END_IF_common_recursion_8
RETURN
# Defining function general_recursion
:FUNCTION_general_recursion
# IF_general_recursion_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_general_recursion_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_common_recursion
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
COPY_edi_to_ebp
CALL_eax
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_general_recursion_0
:ELSE_general_recursion_0
:_END_IF_general_recursion_0
RETURN
# Defining function ceil_log2
:FUNCTION_ceil_log2
# Defining local result
LOAD_IMMEDIATE_eax %0
PUSH_eax	#result
# IF_ceil_log2_0
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_ceil_log2_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_ceil_log2_0
:ELSE_ceil_log2_0
:_END_IF_ceil_log2_0
:WHILE_ceil_log2_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %END_WHILE_ceil_log2_1
# THEN_while_ceil_log2_1
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_ceil_log2_1
:END_WHILE_ceil_log2_1
# IF_ceil_log2_2
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_ceil_log2_2
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_ceil_log2_2
:ELSE_ceil_log2_2
:_END_IF_ceil_log2_2
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function postfix_expr_arrow
:FUNCTION_postfix_expr_arrow
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local i
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_lookup_member
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#i
LOAD_IMMEDIATE_eax &GLOBAL_current_target
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %20
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_postfix_expr_arrow_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_2
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_postfix_expr_arrow_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_4
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_3
:ELSE_postfix_expr_arrow_3
# IF_postfix_expr_arrow_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_6
:ELSE_postfix_expr_arrow_6
# IF_postfix_expr_arrow_9
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_9
:ELSE_postfix_expr_arrow_9
# IF_postfix_expr_arrow_12
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_14
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_12
:ELSE_postfix_expr_arrow_12
:_END_IF_postfix_expr_arrow_12
:_END_IF_postfix_expr_arrow_9
:_END_IF_postfix_expr_arrow_6
:_END_IF_postfix_expr_arrow_3
JUMP %_END_IF_postfix_expr_arrow_1
:ELSE_postfix_expr_arrow_1
:_END_IF_postfix_expr_arrow_1
# IF_postfix_expr_arrow_15
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETGE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_15
# IF_postfix_expr_arrow_17
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_17
:ELSE_postfix_expr_arrow_17
# IF_postfix_expr_arrow_19
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_19
:ELSE_postfix_expr_arrow_19
# IF_postfix_expr_arrow_21
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_21
:ELSE_postfix_expr_arrow_21
# IF_postfix_expr_arrow_23
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_arrow_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_arrow_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_arrow_23
:ELSE_postfix_expr_arrow_23
:_END_IF_postfix_expr_arrow_23
:_END_IF_postfix_expr_arrow_21
:_END_IF_postfix_expr_arrow_19
:_END_IF_postfix_expr_arrow_17
JUMP %_END_IF_postfix_expr_arrow_15
:ELSE_postfix_expr_arrow_15
:_END_IF_postfix_expr_arrow_15
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function postfix_expr_array
:FUNCTION_postfix_expr_array
# Defining local array
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
PUSH_eax	#array
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_expression
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_common_recursion
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_current_target
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local assign
PUSH_eax	#assign
# IF_postfix_expr_array_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_array_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_0
:ELSE_postfix_expr_array_0
# IF_postfix_expr_array_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_2
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_3
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_2
:ELSE_postfix_expr_array_2
# IF_postfix_expr_array_4
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_4
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_5
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_4
:ELSE_postfix_expr_array_4
# IF_postfix_expr_array_6
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_6
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_7
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_6
:ELSE_postfix_expr_array_6
:_END_IF_postfix_expr_array_6
:_END_IF_postfix_expr_array_4
:_END_IF_postfix_expr_array_2
:_END_IF_postfix_expr_array_0
# IF_postfix_expr_array_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_9
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_postfix_expr_array_8
# IF_postfix_expr_array_10
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_array_10
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_11
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_10
:ELSE_postfix_expr_array_10
# IF_postfix_expr_array_12
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_12
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_13
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_12
:ELSE_postfix_expr_array_12
# IF_postfix_expr_array_14
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_14
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_15
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_14
:ELSE_postfix_expr_array_14
# IF_postfix_expr_array_16
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_16
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_17
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_16
:ELSE_postfix_expr_array_16
:_END_IF_postfix_expr_array_16
:_END_IF_postfix_expr_array_14
:_END_IF_postfix_expr_array_12
:_END_IF_postfix_expr_array_10
JUMP %_END_IF_postfix_expr_array_8
:ELSE_postfix_expr_array_8
# IF_postfix_expr_array_18
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_array_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_19
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_18
:ELSE_postfix_expr_array_18
# IF_postfix_expr_array_20
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_20
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_21
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_20
:ELSE_postfix_expr_array_20
# IF_postfix_expr_array_22
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_22
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_23
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_22
:ELSE_postfix_expr_array_22
# IF_postfix_expr_array_24
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_24
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_25
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_24
:ELSE_postfix_expr_array_24
:_END_IF_postfix_expr_array_24
:_END_IF_postfix_expr_array_22
:_END_IF_postfix_expr_array_20
:_END_IF_postfix_expr_array_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %12
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_ceil_log2
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_postfix_expr_array_26
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_27
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_26
:ELSE_postfix_expr_array_26
:_END_IF_postfix_expr_array_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_28
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_postfix_expr_array_8
# IF_postfix_expr_array_29
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_postfix_expr_array_29
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_30
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_29
:ELSE_postfix_expr_array_29
# IF_postfix_expr_array_31
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_31
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_32
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_31
:ELSE_postfix_expr_array_31
# IF_postfix_expr_array_33
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_33
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_34
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_33
:ELSE_postfix_expr_array_33
# IF_postfix_expr_array_35
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_postfix_expr_array_35
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_36
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_array_35
:ELSE_postfix_expr_array_35
:_END_IF_postfix_expr_array_35
:_END_IF_postfix_expr_array_33
:_END_IF_postfix_expr_array_31
:_END_IF_postfix_expr_array_29
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_37
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_38
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_postfix_expr_array_39
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_40
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_postfix_expr_array_39
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_postfix_expr_array_41
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_postfix_expr_array_39
:ELSE_postfix_expr_array_39
:_END_IF_postfix_expr_array_39
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function unary_expr_sizeof
:FUNCTION_unary_expr_sizeof
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_type_name
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_unary_expr_sizeof_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_unary_expr_sizeof_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_unary_expr_sizeof_4
:ELSE_unary_expr_sizeof_4
# IF_unary_expr_sizeof_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_unary_expr_sizeof_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_unary_expr_sizeof_6
:ELSE_unary_expr_sizeof_6
# IF_unary_expr_sizeof_8
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_unary_expr_sizeof_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_unary_expr_sizeof_8
:ELSE_unary_expr_sizeof_8
# IF_unary_expr_sizeof_10
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_unary_expr_sizeof_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_unary_expr_sizeof_10
:ELSE_unary_expr_sizeof_10
:_END_IF_unary_expr_sizeof_10
:_END_IF_unary_expr_sizeof_8
:_END_IF_unary_expr_sizeof_6
:_END_IF_unary_expr_sizeof_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_unary_expr_sizeof_12
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_unary_expr_sizeof_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_unary_expr_sizeof_12
:ELSE_unary_expr_sizeof_12
:_END_IF_unary_expr_sizeof_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_unary_expr_sizeof_14
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function postfix_expr_stub
:FUNCTION_postfix_expr_stub
# IF_postfix_expr_stub_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_stub_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_postfix_expr_stub_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_postfix_expr_array
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_postfix_expr_stub
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_stub_0
:ELSE_postfix_expr_stub_0
:_END_IF_postfix_expr_stub_0
# IF_postfix_expr_stub_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_postfix_expr_stub_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_postfix_expr_stub_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_postfix_expr_arrow
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_postfix_expr_stub
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_postfix_expr_stub_2
:ELSE_postfix_expr_stub_2
:_END_IF_postfix_expr_stub_2
RETURN
# Defining function postfix_expr
:FUNCTION_postfix_expr
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_primary_expr
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_postfix_expr_stub
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function additive_expr_stub
:FUNCTION_additive_expr_stub
# IF_additive_expr_stub_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_additive_expr_stub_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_1
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_2
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_3
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_4
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_5
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_6
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_7
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_8
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_9
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_10
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_11
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_12
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_13
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_14
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_additive_expr_stub_0
:ELSE_additive_expr_stub_0
# IF_additive_expr_stub_15
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_additive_expr_stub_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_16
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_17
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_18
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_19
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_20
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_21
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_22
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_23
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_24
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_25
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_26
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_27
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_28
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_29
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_additive_expr_stub_15
:ELSE_additive_expr_stub_15
# IF_additive_expr_stub_30
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_additive_expr_stub_30
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_31
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_32
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_33
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_34
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_35
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_36
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_37
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_38
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_39
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_40
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_41
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_42
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_43
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_44
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_additive_expr_stub_30
:ELSE_additive_expr_stub_30
# IF_additive_expr_stub_45
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_additive_expr_stub_45
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_46
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_47
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_48
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_49
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_50
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_51
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_52
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_53
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_54
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_55
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_56
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_57
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_58
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_additive_expr_stub_59
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_additive_expr_stub_45
:ELSE_additive_expr_stub_45
:_END_IF_additive_expr_stub_45
:_END_IF_additive_expr_stub_30
:_END_IF_additive_expr_stub_15
:_END_IF_additive_expr_stub_0
RETURN
# Defining function additive_expr
:FUNCTION_additive_expr
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_postfix_expr
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_additive_expr_stub
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function relational_expr_stub
:FUNCTION_relational_expr_stub
# IF_relational_expr_stub_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_relational_expr_stub_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_1
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_2
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_3
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_4
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_5
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_6
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_7
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_8
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_9
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_10
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_11
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_12
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_relational_expr_stub_0
:ELSE_relational_expr_stub_0
# IF_relational_expr_stub_13
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_relational_expr_stub_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_14
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_15
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_16
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_17
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_18
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_19
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_20
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_21
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_22
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_23
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_24
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_25
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_relational_expr_stub_13
:ELSE_relational_expr_stub_13
# IF_relational_expr_stub_26
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_relational_expr_stub_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_27
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_28
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_29
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_30
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_31
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_32
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_33
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_34
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_35
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_36
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_37
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_38
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_relational_expr_stub_26
:ELSE_relational_expr_stub_26
# IF_relational_expr_stub_39
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_relational_expr_stub_39
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_40
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_41
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_42
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_43
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_44
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_45
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_46
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_47
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_48
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_49
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_additive_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_50
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_relational_expr_stub_51
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_relational_expr_stub_39
:ELSE_relational_expr_stub_39
:_END_IF_relational_expr_stub_39
:_END_IF_relational_expr_stub_26
:_END_IF_relational_expr_stub_13
:_END_IF_relational_expr_stub_0
RETURN
# Defining function relational_expr
:FUNCTION_relational_expr
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_additive_expr
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_relational_expr_stub
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function bitwise_expr_stub
:FUNCTION_bitwise_expr_stub
# IF_bitwise_expr_stub_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_bitwise_expr_stub_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_1
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_2
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_3
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_4
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_5
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_6
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_7
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_8
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_9
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_10
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_bitwise_expr_stub_0
:ELSE_bitwise_expr_stub_0
# IF_bitwise_expr_stub_11
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_bitwise_expr_stub_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_12
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_13
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_14
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_15
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_16
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_17
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_18
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_19
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_20
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_21
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_bitwise_expr_stub_11
:ELSE_bitwise_expr_stub_11
# IF_bitwise_expr_stub_22
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_bitwise_expr_stub_22
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_23
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_24
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_25
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_26
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_27
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_28
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_29
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_30
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_31
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_32
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_bitwise_expr_stub_22
:ELSE_bitwise_expr_stub_22
# IF_bitwise_expr_stub_33
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_bitwise_expr_stub_33
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_34
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_35
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_36
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_37
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_38
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_39
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_40
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_41
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_relational_expr
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_42
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_bitwise_expr_stub_43
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &FUNCTION_bitwise_expr_stub
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_general_recursion
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_bitwise_expr_stub_33
:ELSE_bitwise_expr_stub_33
:_END_IF_bitwise_expr_stub_33
:_END_IF_bitwise_expr_stub_22
:_END_IF_bitwise_expr_stub_11
:_END_IF_bitwise_expr_stub_0
RETURN
# Defining function bitwise_expr
:FUNCTION_bitwise_expr
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_relational_expr
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_bitwise_expr_stub
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function primary_expr
:FUNCTION_primary_expr
# IF_primary_expr_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_primary_expr_0
LOAD_IMMEDIATE_eax &GLOBAL_Address_of
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_primary_expr_0
:ELSE_primary_expr_0
LOAD_IMMEDIATE_eax &GLOBAL_Address_of
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_primary_expr_0
# IF_primary_expr_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_primary_expr_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_unary_expr_sizeof
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_2
:ELSE_primary_expr_2
# IF_primary_expr_4
LOAD_IMMEDIATE_eax %45
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_4
# IF_primary_expr_5
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_6
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_5
:ELSE_primary_expr_5
# IF_primary_expr_7
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_7
:ELSE_primary_expr_7
# IF_primary_expr_9
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_9
:ELSE_primary_expr_9
:_END_IF_primary_expr_9
:_END_IF_primary_expr_7
:_END_IF_primary_expr_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_primary_expr
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_common_recursion
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_primary_expr_11
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_primary_expr_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_12
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_11
:ELSE_primary_expr_11
# IF_primary_expr_13
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_14
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_13
:ELSE_primary_expr_13
# IF_primary_expr_15
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_16
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_15
:ELSE_primary_expr_15
# IF_primary_expr_17
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_17
:ELSE_primary_expr_17
:_END_IF_primary_expr_17
:_END_IF_primary_expr_15
:_END_IF_primary_expr_13
:_END_IF_primary_expr_11
JUMP %_END_IF_primary_expr_4
:ELSE_primary_expr_4
# IF_primary_expr_19
LOAD_IMMEDIATE_eax %33
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_19
# IF_primary_expr_20
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_20
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_21
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_20
:ELSE_primary_expr_20
# IF_primary_expr_22
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_22
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_23
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_22
:ELSE_primary_expr_22
# IF_primary_expr_24
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_24
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_25
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_24
:ELSE_primary_expr_24
:_END_IF_primary_expr_24
:_END_IF_primary_expr_22
:_END_IF_primary_expr_20
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_common_recursion
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_primary_expr_26
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_primary_expr_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_27
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_26
:ELSE_primary_expr_26
# IF_primary_expr_28
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_28
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_29
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_28
:ELSE_primary_expr_28
# IF_primary_expr_30
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_30
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_31
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_30
:ELSE_primary_expr_30
# IF_primary_expr_32
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_32
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_33
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_32
:ELSE_primary_expr_32
:_END_IF_primary_expr_32
:_END_IF_primary_expr_30
:_END_IF_primary_expr_28
:_END_IF_primary_expr_26
JUMP %_END_IF_primary_expr_19
:ELSE_primary_expr_19
# IF_primary_expr_34
LOAD_IMMEDIATE_eax %126
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_postfix_expr
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_common_recursion
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_primary_expr_35
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_primary_expr_35
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_36
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_35
:ELSE_primary_expr_35
# IF_primary_expr_37
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_37
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_38
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_37
:ELSE_primary_expr_37
# IF_primary_expr_39
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_39
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_40
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_39
:ELSE_primary_expr_39
# IF_primary_expr_41
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_41
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_42
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_41
:ELSE_primary_expr_41
:_END_IF_primary_expr_41
:_END_IF_primary_expr_39
:_END_IF_primary_expr_37
:_END_IF_primary_expr_35
JUMP %_END_IF_primary_expr_34
:ELSE_primary_expr_34
# IF_primary_expr_43
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %40
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_43
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_primary_expr_44
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_primary_expr_45
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_43
:ELSE_primary_expr_43
# IF_primary_expr_46
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %39
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_46
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_primary_expr_char
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_46
:ELSE_primary_expr_46
# IF_primary_expr_47
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %34
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_primary_expr_47
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_primary_expr_string
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_47
:ELSE_primary_expr_47
# IF_primary_expr_48
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_primary_expr_49
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_primary_expr_48
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_primary_expr_variable
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_48
:ELSE_primary_expr_48
# IF_primary_expr_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_primary_expr_51
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_primary_expr_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_primary_expr_number
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_primary_expr_50
:ELSE_primary_expr_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_primary_expr_failure
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_primary_expr_50
:_END_IF_primary_expr_48
:_END_IF_primary_expr_47
:_END_IF_primary_expr_46
:_END_IF_primary_expr_43
:_END_IF_primary_expr_34
:_END_IF_primary_expr_19
:_END_IF_primary_expr_4
:_END_IF_primary_expr_2
RETURN
# Defining function expression
:FUNCTION_expression
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_bitwise_expr
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_expression_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_expression_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_expression_0
# Defining local store
LOAD_IMMEDIATE_eax &STRING_expression_2
PUSH_eax	#store
# IF_expression_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_expression_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_expression_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_current_target
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %24
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_expression_3
# IF_expression_6
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_expression_6
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_7
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_6
:ELSE_expression_6
# IF_expression_8
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_expression_8
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_9
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_8
:ELSE_expression_8
# IF_expression_10
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_expression_10
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_11
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_10
:ELSE_expression_10
# IF_expression_12
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_expression_12
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_13
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_12
:ELSE_expression_12
:_END_IF_expression_12
:_END_IF_expression_10
:_END_IF_expression_8
:_END_IF_expression_6
JUMP %_END_IF_expression_3
:ELSE_expression_3
# IF_expression_14
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_expression_14
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_15
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_14
:ELSE_expression_14
# IF_expression_16
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_expression_16
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_17
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_16
:ELSE_expression_16
# IF_expression_18
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_expression_18
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_19
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_18
:ELSE_expression_18
# IF_expression_20
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_expression_20
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_expression_21
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_expression_20
:ELSE_expression_20
:_END_IF_expression_20
:_END_IF_expression_18
:_END_IF_expression_16
:_END_IF_expression_14
:_END_IF_expression_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &FUNCTION_expression
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_common_recursion
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_current_target
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_expression_0
:ELSE_expression_0
:_END_IF_expression_0
RETURN
# Defining function collect_local
:FUNCTION_collect_local
# Defining local type_size
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_type_name
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#type_size
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_declare
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
# IF_collect_local_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_collect_local_0
# IF_collect_local_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_2
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_2
:ELSE_collect_local_2
# IF_collect_local_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_3
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %20
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_3
:ELSE_collect_local_3
# IF_collect_local_4
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_4
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %20
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_4
:ELSE_collect_local_4
# IF_collect_local_5
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_5
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %40
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_5
:ELSE_collect_local_5
# IF_collect_local_6
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_6
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_6
:ELSE_collect_local_6
:_END_IF_collect_local_6
:_END_IF_collect_local_5
:_END_IF_collect_local_4
:_END_IF_collect_local_3
:_END_IF_collect_local_2
JUMP %_END_IF_collect_local_0
:ELSE_collect_local_0
# IF_collect_local_7
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_collect_local_7
# IF_collect_local_8
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_collect_local_8
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_8
:ELSE_collect_local_8
# IF_collect_local_9
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_9
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_9
:ELSE_collect_local_9
# IF_collect_local_10
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_10
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_10
:ELSE_collect_local_10
# IF_collect_local_11
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_11
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_11
:ELSE_collect_local_11
:_END_IF_collect_local_11
:_END_IF_collect_local_10
:_END_IF_collect_local_9
:_END_IF_collect_local_8
JUMP %_END_IF_collect_local_7
:ELSE_collect_local_7
# IF_collect_local_12
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_12
# IF_collect_local_13
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_collect_local_13
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_13
:ELSE_collect_local_13
# IF_collect_local_14
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_14
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_14
:ELSE_collect_local_14
# IF_collect_local_15
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_15
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %16
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_15
:ELSE_collect_local_15
# IF_collect_local_16
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_16
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_16
:ELSE_collect_local_16
:_END_IF_collect_local_16
:_END_IF_collect_local_15
:_END_IF_collect_local_14
:_END_IF_collect_local_13
JUMP %_END_IF_collect_local_12
:ELSE_collect_local_12
# IF_collect_local_17
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_collect_local_17
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_17
:ELSE_collect_local_17
# IF_collect_local_18
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_18
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_18
:ELSE_collect_local_18
# IF_collect_local_19
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_19
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_19
:ELSE_collect_local_19
# IF_collect_local_20
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_20
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_local_20
:ELSE_collect_local_20
:_END_IF_collect_local_20
:_END_IF_collect_local_19
:_END_IF_collect_local_18
:_END_IF_collect_local_17
:_END_IF_collect_local_12
:_END_IF_collect_local_7
:_END_IF_collect_local_0
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_21
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_collect_local_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_24
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_collect_local_23
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_collect_local_23
:ELSE_collect_local_23
:_END_IF_collect_local_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_25
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_collect_local_26
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_collect_local_27
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_collect_local_27
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_28
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_collect_local_27
:ELSE_collect_local_27
# IF_collect_local_29
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_29
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_30
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_collect_local_29
:ELSE_collect_local_29
# IF_collect_local_31
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_31
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_32
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_collect_local_31
:ELSE_collect_local_31
# IF_collect_local_33
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_local_33
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_34
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_collect_local_33
:ELSE_collect_local_33
:_END_IF_collect_local_33
:_END_IF_collect_local_31
:_END_IF_collect_local_29
:_END_IF_collect_local_27
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_local_35
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function process_if
:FUNCTION_process_if
# Defining local number_string
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#number_string
LOAD_IMMEDIATE_eax &GLOBAL_current_count
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_if_2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_if_3
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_if_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_4
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_3
:ELSE_process_if_3
# IF_process_if_5
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_6
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_5
:ELSE_process_if_5
# IF_process_if_7
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_7
:ELSE_process_if_7
# IF_process_if_9
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_9
:ELSE_process_if_9
:_END_IF_process_if_9
:_END_IF_process_if_7
:_END_IF_process_if_5
:_END_IF_process_if_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_if_11
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_12
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_11
:ELSE_process_if_11
:_END_IF_process_if_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_13
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_if_14
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_if_15
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_if_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_16
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_15
:ELSE_process_if_15
# IF_process_if_17
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_17
:ELSE_process_if_17
# IF_process_if_19
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_19
:ELSE_process_if_19
# IF_process_if_21
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_21
:ELSE_process_if_21
:_END_IF_process_if_21
:_END_IF_process_if_19
:_END_IF_process_if_17
:_END_IF_process_if_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_if_23
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_if_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_23
:ELSE_process_if_23
:_END_IF_process_if_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_25
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_if_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_27
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_process_if_26
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_if_26
:ELSE_process_if_26
:_END_IF_process_if_26
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_if_28
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function process_for
:FUNCTION_process_for
# Defining local nested_locals
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
LOAD_INTEGER
PUSH_eax	#nested_locals
# Defining local nested_break_head
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
LOAD_INTEGER
PUSH_eax	#nested_break_head
# Defining local nested_break_func
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
LOAD_INTEGER
PUSH_eax	#nested_break_func
# Defining local nested_break_num
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
LOAD_INTEGER
PUSH_eax	#nested_break_num
# Defining local number_string
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#number_string
LOAD_IMMEDIATE_eax &GLOBAL_current_count
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_process_for_0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_for_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_process_for_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_4
:ELSE_process_for_4
:_END_IF_process_for_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_6
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_for_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_9
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_for_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_9
:ELSE_process_for_9
# IF_process_for_11
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_12
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_11
:ELSE_process_for_11
# IF_process_for_13
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_14
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_13
:ELSE_process_for_13
# IF_process_for_15
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_16
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_15
:ELSE_process_for_15
:_END_IF_process_for_15
:_END_IF_process_for_13
:_END_IF_process_for_11
:_END_IF_process_for_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_17
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_17
:ELSE_process_for_17
:_END_IF_process_for_17
# IF_process_for_19
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_for_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_19
:ELSE_process_for_19
# IF_process_for_21
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_21
:ELSE_process_for_21
# IF_process_for_23
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_23
:ELSE_process_for_23
# IF_process_for_25
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_26
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_25
:ELSE_process_for_25
:_END_IF_process_for_25
:_END_IF_process_for_23
:_END_IF_process_for_21
:_END_IF_process_for_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_27
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_27
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_28
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_27
:ELSE_process_for_27
:_END_IF_process_for_27
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_29
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_30
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_for_31
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_32
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_for_32
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_33
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_32
:ELSE_process_for_32
# IF_process_for_34
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_35
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_34
:ELSE_process_for_34
# IF_process_for_36
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_36
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_37
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_36
:ELSE_process_for_36
# IF_process_for_38
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_38
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_39
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_38
:ELSE_process_for_38
:_END_IF_process_for_38
:_END_IF_process_for_36
:_END_IF_process_for_34
:_END_IF_process_for_32
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_40
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_40
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_41
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_40
:ELSE_process_for_40
:_END_IF_process_for_40
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_42
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_43
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_for_44
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_45
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_for_45
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_46
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_45
:ELSE_process_for_45
# IF_process_for_47
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_47
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_48
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_47
:ELSE_process_for_47
# IF_process_for_49
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_49
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_50
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_49
:ELSE_process_for_49
# IF_process_for_51
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_51
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_52
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_51
:ELSE_process_for_51
:_END_IF_process_for_51
:_END_IF_process_for_49
:_END_IF_process_for_47
:_END_IF_process_for_45
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_for_53
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_for_53
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_54
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_for_53
:ELSE_process_for_53
:_END_IF_process_for_53
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_for_55
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function process_asm
:FUNCTION_process_asm
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_asm_0
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_asm_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:WHILE_process_asm_2
LOAD_IMMEDIATE_eax %34
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_process_asm_2
# THEN_while_process_asm_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_asm_3
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_process_asm_2
:END_WHILE_process_asm_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_asm_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_asm_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_asm_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_asm_7
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function process_do
:FUNCTION_process_do
# Defining local nested_locals
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
LOAD_INTEGER
PUSH_eax	#nested_locals
# Defining local nested_break_head
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
LOAD_INTEGER
PUSH_eax	#nested_break_head
# Defining local nested_break_func
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
LOAD_INTEGER
PUSH_eax	#nested_break_func
# Defining local nested_break_num
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
LOAD_INTEGER
PUSH_eax	#nested_break_num
# Defining local number_string
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#number_string
LOAD_IMMEDIATE_eax &GLOBAL_current_count
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_process_do_0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_do_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_do_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_do_7
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_do_9
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_do_10
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_do_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_do_10
:ELSE_process_do_10
# IF_process_do_12
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_do_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_do_12
:ELSE_process_do_12
# IF_process_do_14
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_do_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_15
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_do_14
:ELSE_process_do_14
# IF_process_do_16
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_do_16
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_17
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_do_16
:ELSE_process_do_16
:_END_IF_process_do_16
:_END_IF_process_do_14
:_END_IF_process_do_12
:_END_IF_process_do_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_do_18
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_do_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_19
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_do_18
:ELSE_process_do_18
:_END_IF_process_do_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_do_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function process_while
:FUNCTION_process_while
# Defining local nested_locals
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
LOAD_INTEGER
PUSH_eax	#nested_locals
# Defining local nested_break_head
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
LOAD_INTEGER
PUSH_eax	#nested_break_head
# Defining local nested_break_func
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
LOAD_INTEGER
PUSH_eax	#nested_break_func
# Defining local nested_break_num
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
LOAD_INTEGER
PUSH_eax	#nested_break_num
# Defining local number_string
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#number_string
LOAD_IMMEDIATE_eax &GLOBAL_current_count
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_current_count
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &STRING_process_while_0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_while_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_while_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_while_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_4
:ELSE_process_while_4
# IF_process_while_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_6
:ELSE_process_while_6
# IF_process_while_8
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_8
:ELSE_process_while_8
# IF_process_while_10
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_10
:ELSE_process_while_10
:_END_IF_process_while_10
:_END_IF_process_while_8
:_END_IF_process_while_6
:_END_IF_process_while_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_while_12
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_12
:ELSE_process_while_12
:_END_IF_process_while_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_14
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_15
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_while_16
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_while_17
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_while_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_17
:ELSE_process_while_17
# IF_process_while_19
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_19
:ELSE_process_while_19
# IF_process_while_21
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_21
:ELSE_process_while_21
# IF_process_while_23
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_23
:ELSE_process_while_23
:_END_IF_process_while_23
:_END_IF_process_while_21
:_END_IF_process_while_19
:_END_IF_process_while_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_while_25
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_while_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_26
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_while_25
:ELSE_process_while_25
:_END_IF_process_while_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_while_27
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_uniqueID_out
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function return_result
:FUNCTION_return_result
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_return_result_0
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %59
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_0
:ELSE_return_result_0
:_END_IF_return_result_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_return_result_2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local i
PUSH_eax	#i
# FOR_initialization_return_result_3
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_return_result_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_return_result_3
JUMP %FOR_THEN_return_result_3
:FOR_ITER_return_result_3
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_return_result_3
:FOR_THEN_return_result_3
# IF_return_result_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_return_result_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_4
:ELSE_return_result_4
# IF_return_result_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_6
:ELSE_return_result_6
# IF_return_result_8
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_8
:ELSE_return_result_8
# IF_return_result_10
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_10
:ELSE_return_result_10
:_END_IF_return_result_10
:_END_IF_return_result_8
:_END_IF_return_result_6
:_END_IF_return_result_4
JUMP %FOR_ITER_return_result_3
:FOR_END_return_result_3
# IF_return_result_12
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_return_result_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_12
:ELSE_return_result_12
# IF_return_result_14
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_15
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_14
:ELSE_return_result_14
# IF_return_result_16
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_16
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_17
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_16
:ELSE_return_result_16
# IF_return_result_18
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_return_result_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_return_result_19
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_return_result_18
:ELSE_return_result_18
:_END_IF_return_result_18
:_END_IF_return_result_16
:_END_IF_return_result_14
:_END_IF_return_result_12
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function process_break
:FUNCTION_process_break
# IF_process_break_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_0
:ELSE_process_break_0
:_END_IF_process_break_0
# Defining local i
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#i
:WHILE_process_break_2
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_break_frame
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_process_break_2
# THEN_while_process_break_2
# IF_process_break_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_3
JUMP %END_WHILE_process_break_2
JUMP %_END_IF_process_break_3
:ELSE_process_break_3
:_END_IF_process_break_3
# IF_process_break_4
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_break_4
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_5
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_4
:ELSE_process_break_4
# IF_process_break_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_6
:ELSE_process_break_6
# IF_process_break_8
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_8
:ELSE_process_break_8
# IF_process_break_10
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_10
:ELSE_process_break_10
:_END_IF_process_break_10
:_END_IF_process_break_8
:_END_IF_process_break_6
:_END_IF_process_break_4
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_process_break_2
:END_WHILE_process_break_2
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_process_break_12
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_process_break_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_12
:ELSE_process_break_12
# IF_process_break_14
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_15
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_14
:ELSE_process_break_14
# IF_process_break_16
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_16
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_17
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_16
:ELSE_process_break_16
# IF_process_break_18
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_19
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_18
:ELSE_process_break_18
:_END_IF_process_break_18
:_END_IF_process_break_16
:_END_IF_process_break_14
:_END_IF_process_break_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_break_target_head
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_break_target_func
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_break_target_num
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_process_break_21
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_process_break_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_process_break_21
:ELSE_process_break_21
:_END_IF_process_break_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_23
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_process_break_24
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_process_break_25
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function recursive_statement
:FUNCTION_recursive_statement
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local frame
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#frame
:WHILE_recursive_statement_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %END_WHILE_recursive_statement_0
# THEN_while_recursive_statement_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %WHILE_recursive_statement_0
:END_WHILE_recursive_statement_0
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_recursive_statement_2
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_recursive_statement_2
# Defining local i
PUSH_eax	#i
# FOR_initialization_recursive_statement_7
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_recursive_statement_7
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_recursive_statement_7
JUMP %FOR_THEN_recursive_statement_7
:FOR_ITER_recursive_statement_7
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_recursive_statement_7
:FOR_THEN_recursive_statement_7
# IF_recursive_statement_8
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_recursive_statement_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_recursive_statement_8
:ELSE_recursive_statement_8
# IF_recursive_statement_10
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_recursive_statement_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_11
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_recursive_statement_10
:ELSE_recursive_statement_10
# IF_recursive_statement_12
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_recursive_statement_12
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_recursive_statement_12
:ELSE_recursive_statement_12
# IF_recursive_statement_14
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_recursive_statement_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_recursive_statement_15
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_recursive_statement_14
:ELSE_recursive_statement_14
:_END_IF_recursive_statement_14
:_END_IF_recursive_statement_12
:_END_IF_recursive_statement_10
:_END_IF_recursive_statement_8
JUMP %FOR_ITER_recursive_statement_7
:FOR_END_recursive_statement_7
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_recursive_statement_2
:ELSE_recursive_statement_2
:_END_IF_recursive_statement_2
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function statement
:FUNCTION_statement
# IF_statement_0
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %123
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_statement_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_recursive_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_0
:ELSE_statement_0
# IF_statement_1
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_statement_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_2
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_statement_1
:ELSE_statement_1
# IF_statement_3
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_prim_types
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_lookup_type
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_statement_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_collect_local
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_3
:ELSE_statement_3
# IF_statement_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_if
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_5
:ELSE_statement_5
# IF_statement_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_do
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_7
:ELSE_statement_7
# IF_statement_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_10
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_while
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_9
:ELSE_statement_9
# IF_statement_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_for
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_11
:ELSE_statement_11
# IF_statement_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_14
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_asm
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_13
:ELSE_statement_13
# IF_statement_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_15
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_statement_17
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_statement_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_18
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_17
:ELSE_statement_17
# IF_statement_19
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_statement_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_20
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_19
:ELSE_statement_19
# IF_statement_21
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_statement_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_21
:ELSE_statement_21
# IF_statement_23
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_statement_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_24
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_23
:ELSE_statement_23
:_END_IF_statement_23
:_END_IF_statement_21
:_END_IF_statement_19
:_END_IF_statement_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_statement_25
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_statement_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_26
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_25
:ELSE_statement_25
:_END_IF_statement_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_27
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_28
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_statement_29
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_15
:ELSE_statement_15
# IF_statement_30
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_31
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_30
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_return_result
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_30
:ELSE_statement_30
# IF_statement_32
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_33
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_32
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_process_break
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_32
:ELSE_statement_32
# IF_statement_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_35
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_statement_34
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_36
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_37
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_statement_38
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_statement_34
:ELSE_statement_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_expression
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_statement_39
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_statement_40
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_statement_34
:_END_IF_statement_32
:_END_IF_statement_30
:_END_IF_statement_15
:_END_IF_statement_13
:_END_IF_statement_11
:_END_IF_statement_9
:_END_IF_statement_7
:_END_IF_statement_5
:_END_IF_statement_3
:_END_IF_statement_1
:_END_IF_statement_0
RETURN
# Defining function collect_arguments
:FUNCTION_collect_arguments
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:WHILE_collect_arguments_0
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_collect_arguments_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %END_WHILE_collect_arguments_0
# THEN_while_collect_arguments_0
# Defining local type_size
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_type_name
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#type_size
# IF_collect_arguments_2
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %41
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_2

#continue statement
JUMP %_END_IF_collect_arguments_2
:ELSE_collect_arguments_2
# IF_collect_arguments_3
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %44
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_3
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_declare
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
# IF_collect_arguments_4
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_4
# IF_collect_arguments_5
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_collect_arguments_5
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_5
:ELSE_collect_arguments_5
# IF_collect_arguments_6
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_6
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_6
:ELSE_collect_arguments_6
# IF_collect_arguments_7
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_7
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %8
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_7
:ELSE_collect_arguments_7
# IF_collect_arguments_8
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_8
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_8
:ELSE_collect_arguments_8
:_END_IF_collect_arguments_8
:_END_IF_collect_arguments_7
:_END_IF_collect_arguments_6
:_END_IF_collect_arguments_5
JUMP %_END_IF_collect_arguments_4
:ELSE_collect_arguments_4
# IF_collect_arguments_9
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_collect_arguments_9
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_9
:ELSE_collect_arguments_9
# IF_collect_arguments_10
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_10
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_10
:ELSE_collect_arguments_10
# IF_collect_arguments_11
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_11
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_11
:ELSE_collect_arguments_11
# IF_collect_arguments_12
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_12
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_register_size
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_12
:ELSE_collect_arguments_12
:_END_IF_collect_arguments_12
:_END_IF_collect_arguments_11
:_END_IF_collect_arguments_10
:_END_IF_collect_arguments_9
:_END_IF_collect_arguments_4
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_collect_arguments_3
:ELSE_collect_arguments_3
:_END_IF_collect_arguments_3
:_END_IF_collect_arguments_2
# IF_collect_arguments_13
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %44
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_collect_arguments_13
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_collect_arguments_13
:ELSE_collect_arguments_13
:_END_IF_collect_arguments_13
POP_ebx	# _recursive_statement_locals
JUMP %WHILE_collect_arguments_0
:END_WHILE_collect_arguments_0
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
RETURN
# Defining function declare_function
:FUNCTION_declare_function
LOAD_IMMEDIATE_eax &GLOBAL_current_count
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_function
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &GLOBAL_global_function_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_declare
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_function_list
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_declare_function_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_declare_function_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_declare_function_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_declare_function_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_declare_function_0
:ELSE_declare_function_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_collect_arguments
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_declare_function_0
# IF_declare_function_6
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %59
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_declare_function_6
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_declare_function_6
:ELSE_declare_function_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_7
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_8
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_9
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_function
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_10
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_statement
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_declare_function_11
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_declare_function_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_13
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_declare_function_11
:ELSE_declare_function_11
# IF_declare_function_14
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_15
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_declare_function_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_16
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_declare_function_14
:ELSE_declare_function_14
# IF_declare_function_17
LOAD_IMMEDIATE_eax %3
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_18
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_declare_function_17
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_19
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_declare_function_17
:ELSE_declare_function_17
# IF_declare_function_20
LOAD_IMMEDIATE_eax %4
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_21
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %ELSE_declare_function_20
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_declare_function_22
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit_out
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_declare_function_20
:ELSE_declare_function_20
:_END_IF_declare_function_20
:_END_IF_declare_function_17
:_END_IF_declare_function_14
:_END_IF_declare_function_11
:_END_IF_declare_function_6
RETURN
# Defining function program
:FUNCTION_program
LOAD_IMMEDIATE_eax &GLOBAL_out
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_function
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_Address_of
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local type_size
PUSH_eax	#type_size
:new_type	#C goto label
# IF_program_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_program_0
LOAD_IMMEDIATE_eax &GLOBAL_out
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_program_0
:ELSE_program_0
:_END_IF_program_0
# IF_program_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_program_1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_constant_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &GLOBAL_global_constant_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_declare
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_program_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_program_3
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_program_6
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_type_name
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#a
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_program_8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_numerate_number
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_constant_list
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_program_3
:ELSE_program_3
LOAD_IMMEDIATE_eax &GLOBAL_global_constant_list
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %16
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_program_3
JUMP %_END_IF_program_1
:ELSE_program_1
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_type_name
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_program_9
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_program_9
JUMP %new_type
JUMP %_END_IF_program_9
:ELSE_program_9
:_END_IF_program_9
LOAD_IMMEDIATE_eax &GLOBAL_global_symbol_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &GLOBAL_global_symbol_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_sym_declare
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_program_10
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_11
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_program_10
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_12
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_13
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_program_10
:ELSE_program_10
# IF_program_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_15
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_program_14
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_declare_function
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_program_14
:ELSE_program_14
# IF_program_16
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_17
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_program_16
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_18
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_19
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_program_20
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_program_21
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_in_set
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_program_20
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_22
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_23
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_program_20
:ELSE_program_20
# IF_program_24
LOAD_IMMEDIATE_eax %34
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_program_24
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_25
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_26
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_27
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_28
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_parse_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_emit
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_program_24
:ELSE_program_24
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_29
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_30
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_program_24
:_END_IF_program_20
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_31
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_program_32
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_require_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_program_16
:ELSE_program_16
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_error
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_33
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_program_34
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_program_16
:_END_IF_program_14
:_END_IF_program_10
:_END_IF_program_1
JUMP %new_type
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function recursive_output
:FUNCTION_recursive_output
# IF_recursive_output_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_recursive_output_0
RETURN
JUMP %_END_IF_recursive_output_0
:ELSE_recursive_output_0
:_END_IF_recursive_output_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_recursive_output
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %8
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
RETURN
# Defining function main
:FUNCTION_main
LOAD_IMMEDIATE_eax &GLOBAL_hold_string
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local DEBUG
LOAD_IMMEDIATE_eax %0
PUSH_eax	#DEBUG
# Defining local in
LOAD_IMMEDIATE_eax %0
PUSH_eax	#in
# Defining local destination_file
LOAD_IMMEDIATE_eax %1
PUSH_eax	#destination_file
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local arch
PUSH_eax	#arch
# Defining local i
LOAD_IMMEDIATE_eax %1
PUSH_eax	#i
:WHILE_main_0
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_main_0
# THEN_while_main_0
# IF_main_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_1
LOAD_BASE_ADDRESS_eax %-36
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_1
:ELSE_main_1
# IF_main_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_3
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_2
# Defining local name
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#name
LOAD_BASE_ADDRESS_eax %-24
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-40
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_6
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-40
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_8
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_6
:ELSE_main_6
:_END_IF_main_6
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-40
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_read_all_tokens
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-36
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_main_2
:ELSE_main_2
# IF_main_9
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_10
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_11
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_9
LOAD_BASE_ADDRESS_eax %-28
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_12
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_13
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_13
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_14
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_15
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_13
:ELSE_main_13
:_END_IF_main_13
LOAD_BASE_ADDRESS_eax %-36
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_9
:ELSE_main_9
# IF_main_16
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_17
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_18
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_16
LOAD_BASE_ADDRESS_eax %-32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_19
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_20
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_19
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_19
:ELSE_main_19
# IF_main_21
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_22
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_21
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_21
:ELSE_main_21
# IF_main_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_24
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_23
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_23
:ELSE_main_23
# IF_main_25
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_26
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_25
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %3
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_25
:ELSE_main_25
# IF_main_27
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_28
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
TEST
JUMP_EQ %ELSE_main_27
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %4
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_27
:ELSE_main_27
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_29
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-32
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_30
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_main_27
:_END_IF_main_25
:_END_IF_main_23
:_END_IF_main_21
:_END_IF_main_19
LOAD_BASE_ADDRESS_eax %-36
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_16
:ELSE_main_16
# IF_main_31
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_32
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_33
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_31
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-36
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_31
:ELSE_main_31
# IF_main_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_35
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_36
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_34
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_37
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_34
:ELSE_main_34
# IF_main_38
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_39
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-36
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_40
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_38
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_41
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_38
:ELSE_main_38
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_42
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_main_38
:_END_IF_main_34
:_END_IF_main_31
:_END_IF_main_16
:_END_IF_main_9
:_END_IF_main_2
:_END_IF_main_1
JUMP %WHILE_main_0
:END_WHILE_main_0
# IF_main_43
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_43
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-24
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax &STRING_main_44
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_read_all_tokens
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_43
:ELSE_main_43
:_END_IF_main_43
# IF_main_45
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_45
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_46
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_45
:ELSE_main_45
:_END_IF_main_45
LOAD_IMMEDIATE_eax &GLOBAL_global_token
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_global_token
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_reverse_list
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_initialize_types
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_reset_hold_string
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local output_list
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_program
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#output_list
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_47
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-40
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_recursive_output
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_main_48
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_48
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_49
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_48
:ELSE_main_48
# IF_main_50
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_main_50
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_51
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_50
:ELSE_main_50
:_END_IF_main_50
:_END_IF_main_48
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_52
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_globals_list
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_recursive_output
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_53
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_strings_list
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_recursive_output
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_main_54
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_Architecture
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_54
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_55
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_54
:ELSE_main_54
# IF_main_56
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
XOR_ebx_eax_into_eax
TEST
JUMP_EQ %ELSE_main_56
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_57
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-28
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_56
:ELSE_main_56
:_END_IF_main_56
:_END_IF_main_54
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN

# Program global variables
:GLOBAL_global_types
NOP
:GLOBAL_prim_types
NOP
:GLOBAL_global_token
NOP
:GLOBAL_strings_list
NOP
:GLOBAL_globals_list
NOP
:GLOBAL_hold_string
NOP
:GLOBAL_string_index
NOP
:GLOBAL_Architecture
NOP
:GLOBAL_register_size
NOP
:GLOBAL_input
NOP
:GLOBAL_token
NOP
:GLOBAL_line
NOP
:GLOBAL_file
NOP
:GLOBAL_member_size
NOP
:GLOBAL_global_symbol_list
NOP
:GLOBAL_global_function_list
NOP
:GLOBAL_global_constant_list
NOP
:GLOBAL_function
NOP
:GLOBAL_out
NOP
:GLOBAL_current_target
NOP
:GLOBAL_break_target_head
NOP
:GLOBAL_break_target_func
NOP
:GLOBAL_break_target_num
NOP
:GLOBAL_break_frame
NOP
:GLOBAL_current_count
NOP
:GLOBAL_last_type
NOP
:GLOBAL_Address_of
NOP

# Program strings
:STRING_toupper_1
"abcdefghijklmnopqrstuvwxyz"
:STRING_numerate_string_2
"01"
:STRING_numerate_string_4
"0123456789ABCDEFabcdef"
:STRING_numerate_string_6
"01234567"
:STRING_numerate_string_7
"0123456789"
:STRING_get_token_3
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
:STRING_get_token_4
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
:STRING_get_token_7
"<=>|&!-"
:STRING_get_token_8
"<=>|&!-"
:STRING_get_token_10
' 27 22 00'
:STRING_upcase_1
"abcdefghijklmnopqrstuvwxyz"
:STRING_hexify_1
"Tried to print non-hex number
"
:STRING_weird_4
"	
 !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
:STRING_weird_6
' 20 09 0A 0D 00'
:STRING_escape_lookup_12
"Unknown escape recieved: "
:STRING_escape_lookup_13
" Unable to process
"
:STRING_collect_weird_string_0
"0123456789ABCDEF"
:STRING_initialize_types_1
"void"
:STRING_initialize_types_2
"int"
:STRING_initialize_types_3
"char*"
:STRING_initialize_types_4
"char"
:STRING_initialize_types_5
"char**"
:STRING_initialize_types_6
"FILE"
:STRING_initialize_types_7
"FUNCTION"
:STRING_initialize_types_8
"unsigned"
:STRING_initialize_types_9
"SCM"
:STRING_lookup_member_2
"ERROR in lookup_member "
:STRING_lookup_member_3
"->"
:STRING_lookup_member_4
" does not exist
"
:STRING_lookup_member_5
"
"
:STRING_build_member_1
"["
:STRING_build_member_2
"Struct only supports [num] form
"
:STRING_build_member_3
"]"
:STRING_build_union_0
"ERROR in build_union
Missing {
"
:STRING_build_union_1
"{"
:STRING_build_union_4
"ERROR in build_union
Missing ;
"
:STRING_build_union_5
";"
:STRING_create_struct_0
"ERROR in create_struct
 Missing {
"
:STRING_create_struct_1
"{"
:STRING_create_struct_4
"union"
:STRING_create_struct_5
"ERROR in create_struct
 Missing ;
"
:STRING_create_struct_6
";"
:STRING_create_struct_7
"ERROR in create_struct
 Missing ;
"
:STRING_create_struct_8
";"
:STRING_type_name_0
"struct"
:STRING_type_name_3
"Unknown type "
:STRING_type_name_4
"
"
:STRING_uniqueID_0
"
"
:STRING_uniqueID_1
"_"
:STRING_line_error_0
":"
:STRING_line_error_1
":"
:STRING_function_call_0
"ERROR in process_expression_list
No ( was found
"
:STRING_function_call_1
"("
:STRING_function_call_3
"PUSHR R13 R15	# Prevent overwriting in recursion
"
:STRING_function_call_4
"PUSHR R14 R15	# Protect the old base pointer
"
:STRING_function_call_5
"COPY R13 R15	# Copy new base pointer
"
:STRING_function_call_7
"PUSH_edi	# Prevent overwriting in recursion
"
:STRING_function_call_8
"PUSH_ebp	# Protect the old base pointer
"
:STRING_function_call_9
"COPY_esp_to_edi	# Copy new base pointer
"
:STRING_function_call_11
"PUSH_RDI	# Prevent overwriting in recursion
"
:STRING_function_call_12
"PUSH_RBP	# Protect the old base pointer
"
:STRING_function_call_13
"COPY_RSP_to_RDI	# Copy new base pointer
"
:STRING_function_call_15
"{R11} PUSH_ALWAYS	# Prevent overwriting in recursion
"
:STRING_function_call_16
"{BP} PUSH_ALWAYS	# Protect the old base pointer
"
:STRING_function_call_17
"'0' SP R11 NO_SHIFT MOVE_ALWAYS	# Copy new base pointer
"
:STRING_function_call_20
"PUSHR R0 R15	#_process_expression1
"
:STRING_function_call_22
"PUSH_eax	#_process_expression1
"
:STRING_function_call_24
"PUSH_RAX	#_process_expression1
"
:STRING_function_call_26
"{R0} PUSH_ALWAYS	#_process_expression1
"
:STRING_function_call_29
"PUSHR R0 R15	#_process_expression2
"
:STRING_function_call_31
"PUSH_eax	#_process_expression2
"
:STRING_function_call_33
"PUSH_RAX	#_process_expression2
"
:STRING_function_call_35
"{R0} PUSH_ALWAYS	#_process_expression2
"
:STRING_function_call_36
"ERROR in process_expression_list
No ) was found
"
:STRING_function_call_37
")"
:STRING_function_call_40
"LOAD R0 R14 "
:STRING_function_call_41
"
MOVE R14 R13
"
:STRING_function_call_42
"CALL R0 R15
"
:STRING_function_call_44
"LOAD_BASE_ADDRESS_eax %"
:STRING_function_call_45
"
LOAD_INTEGER
"
:STRING_function_call_46
"COPY_edi_to_ebp
"
:STRING_function_call_47
"CALL_eax
"
:STRING_function_call_49
"LOAD_BASE_ADDRESS_rax %"
:STRING_function_call_50
"
LOAD_INTEGER
"
:STRING_function_call_51
"COPY_rdi_to_rbp
"
:STRING_function_call_52
"CALL_rax
"
:STRING_function_call_54
"!"
:STRING_function_call_55
" R0 SUB BP ARITH_ALWAYS
"
:STRING_function_call_56
"!0 R0 LOAD32 R0 MEMORY
"
:STRING_function_call_57
"{LR} PUSH_ALWAYS	# Protect the old link register
"
:STRING_function_call_58
"'0' R11 BP NO_SHIFT MOVE_ALWAYS
"
:STRING_function_call_59
"'3' R0 CALL_REG_ALWAYS
"
:STRING_function_call_60
"{LR} POP_ALWAYS	# Prevent overwrite
"
:STRING_function_call_62
"MOVE R14 R13
"
:STRING_function_call_63
"CALLI R15 @FUNCTION_"
:STRING_function_call_64
"
"
:STRING_function_call_66
"MOVE R14 R13
"
:STRING_function_call_67
"LOADR R0 4
JUMP 4
&FUNCTION_"
:STRING_function_call_68
"
CALL R0 R15
"
:STRING_function_call_70
"COPY_edi_to_ebp
"
:STRING_function_call_71
"CALL_IMMEDIATE %FUNCTION_"
:STRING_function_call_72
"
"
:STRING_function_call_74
"COPY_rdi_to_rbp
"
:STRING_function_call_75
"CALL_IMMEDIATE %FUNCTION_"
:STRING_function_call_76
"
"
:STRING_function_call_78
"{LR} PUSH_ALWAYS	# Protect the old link register
"
:STRING_function_call_79
"'0' R11 BP NO_SHIFT MOVE_ALWAYS
"
:STRING_function_call_80
"^~FUNCTION_"
:STRING_function_call_81
" CALL_ALWAYS
"
:STRING_function_call_82
"{LR} POP_ALWAYS	# Restore the old link register
"
:STRING_function_call_85
"POPR R1 R15	# _process_expression_locals
"
:STRING_function_call_87
"POP_ebx	# _process_expression_locals
"
:STRING_function_call_89
"POP_RBX	# _process_expression_locals
"
:STRING_function_call_91
"{R1} POP_ALWAYS	# _process_expression_locals
"
:STRING_function_call_93
"POPR R14 R15	# Restore old base pointer
"
:STRING_function_call_94
"POPR R13 R15	# Prevent overwrite
"
:STRING_function_call_96
"POP_ebp	# Restore old base pointer
"
:STRING_function_call_97
"POP_edi	# Prevent overwrite
"
:STRING_function_call_99
"POP_RBP	# Restore old base pointer
"
:STRING_function_call_100
"POP_RDI	# Prevent overwrite
"
:STRING_function_call_102
"{BP} POP_ALWAYS	# Restore old base pointer
"
:STRING_function_call_103
"{R11} POP_ALWAYS	# Prevent overwrite
"
:STRING_constant_load_1
"LOADI R0 "
:STRING_constant_load_3
"LOAD_IMMEDIATE_eax %"
:STRING_constant_load_5
"LOAD_IMMEDIATE_rax %"
:STRING_constant_load_7
"!0 R0 LOAD32 R15 MEMORY
~0 JUMP_ALWAYS
%"
:STRING_constant_load_8
"
"
:STRING_variable_load_1
"FUNCTION"
:STRING_variable_load_2
"("
:STRING_variable_load_4
"ADDI R0 R14 "
:STRING_variable_load_6
"LOAD_BASE_ADDRESS_eax %"
:STRING_variable_load_8
"LOAD_BASE_ADDRESS_rax %"
:STRING_variable_load_10
"!"
:STRING_variable_load_12
" R0 SUB BP ARITH_ALWAYS"
:STRING_variable_load_13
"
"
:STRING_variable_load_16
"="
:STRING_variable_load_18
"LOAD R0 R0 0
"
:STRING_variable_load_20
"LOAD_INTEGER
"
:STRING_variable_load_22
"LOAD_INTEGER
"
:STRING_variable_load_24
"!0 R0 LOAD32 R0 MEMORY
"
:STRING_function_load_1
"("
:STRING_function_load_3
"LOADUI R0 $FUNCTION_"
:STRING_function_load_5
"LOADR R0 4
JUMP 4
&FUNCTION_"
:STRING_function_load_7
"LOAD_IMMEDIATE_eax &FUNCTION_"
:STRING_function_load_9
"LOAD_IMMEDIATE_rax &FUNCTION_"
:STRING_function_load_11
"!0 R0 LOAD32 R15 MEMORY
~0 JUMP_ALWAYS
&FUNCTION_"
:STRING_function_load_12
"
"
:STRING_global_load_1
"LOADUI R0 $GLOBAL_"
:STRING_global_load_3
"LOADR R0 4
JUMP 4
&GLOBAL_"
:STRING_global_load_5
"LOAD_IMMEDIATE_eax &GLOBAL_"
:STRING_global_load_7
"LOAD_IMMEDIATE_rax &GLOBAL_"
:STRING_global_load_9
"!0 R0 LOAD32 R15 MEMORY
~0 JUMP_ALWAYS
&GLOBAL_"
:STRING_global_load_10
"
"
:STRING_global_load_12
"="
:STRING_global_load_14
"LOAD R0 R0 0
"
:STRING_global_load_16
"LOAD_INTEGER
"
:STRING_global_load_18
"LOAD_INTEGER
"
:STRING_global_load_20
"!0 R0 LOAD32 R0 MEMORY
"
:STRING_primary_expr_failure_0
"Recieved "
:STRING_primary_expr_failure_1
" in primary_expr
"
:STRING_primary_expr_string_1
"LOADUI R0 $STRING_"
:STRING_primary_expr_string_3
"LOADR R0 4
JUMP 4
&STRING_"
:STRING_primary_expr_string_5
"LOAD_IMMEDIATE_eax &STRING_"
:STRING_primary_expr_string_7
"LOAD_IMMEDIATE_rax &STRING_"
:STRING_primary_expr_string_9
"!0 R0 LOAD32 R15 MEMORY
~0 JUMP_ALWAYS
&STRING_"
:STRING_primary_expr_string_10
":STRING_"
:STRING_primary_expr_char_1
"LOADI R0 "
:STRING_primary_expr_char_3
"LOAD_IMMEDIATE_eax %"
:STRING_primary_expr_char_5
"LOAD_IMMEDIATE_rax %"
:STRING_primary_expr_char_7
"!"
:STRING_primary_expr_char_9
" R0 LOADI8_ALWAYS"
:STRING_primary_expr_char_10
"
"
:STRING_primary_expr_number_2
"LOADI R0 "
:STRING_primary_expr_number_3
"LOADR R0 4
JUMP 4
'"
:STRING_primary_expr_number_4
"'"
:STRING_primary_expr_number_6
"LOAD_IMMEDIATE_eax %"
:STRING_primary_expr_number_8
"LOAD_IMMEDIATE_rax %"
:STRING_primary_expr_number_10
"!0 R0 LOAD32 R15 MEMORY
~0 JUMP_ALWAYS
%"
:STRING_primary_expr_number_11
"
"
:STRING_primary_expr_variable_5
" is not a defined symbol
"
:STRING_common_recursion_1
"PUSHR R0 R15	#_common_recursion
"
:STRING_common_recursion_3
"PUSH_eax	#_common_recursion
"
:STRING_common_recursion_5
"PUSH_RAX	#_common_recursion
"
:STRING_common_recursion_7
"{R0} PUSH_ALWAYS	#_common_recursion
"
:STRING_common_recursion_9
"POPR R1 R15	# _common_recursion
"
:STRING_common_recursion_11
"POP_ebx	# _common_recursion
"
:STRING_common_recursion_13
"POP_RBX	# _common_recursion
"
:STRING_common_recursion_15
"{R1} POP_ALWAYS	# _common_recursion
"
:STRING_postfix_expr_arrow_0
"# looking up offset
"
:STRING_postfix_expr_arrow_2
"# -> offset calculation
"
:STRING_postfix_expr_arrow_4
"ADDUI R0 R0 "
:STRING_postfix_expr_arrow_5
"
"
:STRING_postfix_expr_arrow_7
"LOAD_IMMEDIATE_ebx %"
:STRING_postfix_expr_arrow_8
"
ADD_ebx_to_eax
"
:STRING_postfix_expr_arrow_10
"LOAD_IMMEDIATE_rbx %"
:STRING_postfix_expr_arrow_11
"
ADD_rbx_to_rax
"
:STRING_postfix_expr_arrow_13
"!0 R1 LOAD32 R15 MEMORY
~0 JUMP_ALWAYS
%"
:STRING_postfix_expr_arrow_14
"
'0' R0 R0 ADD R1 ARITH2_ALWAYS
"
:STRING_postfix_expr_arrow_16
"="
:STRING_postfix_expr_arrow_18
"LOAD R0 R0 0
"
:STRING_postfix_expr_arrow_20
"LOAD_INTEGER
"
:STRING_postfix_expr_arrow_22
"LOAD_INTEGER
"
:STRING_postfix_expr_arrow_24
"!0 R0 LOAD32 R0 MEMORY
"
:STRING_postfix_expr_array_1
"LOAD R0 R0 0
"
:STRING_postfix_expr_array_3
"LOAD_INTEGER
"
:STRING_postfix_expr_array_5
"LOAD_INTEGER
"
:STRING_postfix_expr_array_7
"!0 R0 LOAD32 R0 MEMORY
"
:STRING_postfix_expr_array_9
"char*"
:STRING_postfix_expr_array_11
"LOAD8 R0 R0 0
"
:STRING_postfix_expr_array_13
"LOAD_BYTE
"
:STRING_postfix_expr_array_15
"LOAD_BYTE
"
:STRING_postfix_expr_array_17
"!0 R0 LOAD8 R0 MEMORY
"
:STRING_postfix_expr_array_19
"SALI R0 "
:STRING_postfix_expr_array_21
"SAL_eax_Immediate8 !"
:STRING_postfix_expr_array_23
"SAL_rax_Immediate8 !"
:STRING_postfix_expr_array_25
"'0' R0 R0 '"
:STRING_postfix_expr_array_27
"' MOVE_ALWAYS"
:STRING_postfix_expr_array_28
"
"
:STRING_postfix_expr_array_30
"ADD R0 R0 R1
"
:STRING_postfix_expr_array_32
"ADD_ebx_to_eax
"
:STRING_postfix_expr_array_34
"ADD_rbx_to_rax
"
:STRING_postfix_expr_array_36
"'0' R0 R0 ADD R1 ARITH2_ALWAYS
"
:STRING_postfix_expr_array_37
"ERROR in postfix_expr
Missing ]
"
:STRING_postfix_expr_array_38
"]"
:STRING_postfix_expr_array_40
"="
:STRING_postfix_expr_array_41
""
:STRING_unary_expr_sizeof_0
"ERROR in unary_expr
Missing (
"
:STRING_unary_expr_sizeof_1
"("
:STRING_unary_expr_sizeof_2
"ERROR in unary_expr
Missing )
"
:STRING_unary_expr_sizeof_3
")"
:STRING_unary_expr_sizeof_5
"LOADUI R0 "
:STRING_unary_expr_sizeof_7
"LOAD_IMMEDIATE_eax %"
:STRING_unary_expr_sizeof_9
"LOAD_IMMEDIATE_rax %"
:STRING_unary_expr_sizeof_11
"!"
:STRING_unary_expr_sizeof_13
" R0 LOADI8_ALWAYS"
:STRING_unary_expr_sizeof_14
"
"
:STRING_postfix_expr_stub_1
"["
:STRING_postfix_expr_stub_3
"->"
:STRING_additive_expr_stub_1
"ADD R0 R1 R0
"
:STRING_additive_expr_stub_2
"+"
:STRING_additive_expr_stub_3
"SUB R0 R1 R0
"
:STRING_additive_expr_stub_4
"-"
:STRING_additive_expr_stub_5
"MUL R0 R1 R0
"
:STRING_additive_expr_stub_6
"*"
:STRING_additive_expr_stub_7
"DIVU R0 R1 R0
"
:STRING_additive_expr_stub_8
"/"
:STRING_additive_expr_stub_9
"MODU R0 R1 R0
"
:STRING_additive_expr_stub_10
"%"
:STRING_additive_expr_stub_11
"SAL R0 R1 R0
"
:STRING_additive_expr_stub_12
"<<"
:STRING_additive_expr_stub_13
"SAR R0 R1 R0
"
:STRING_additive_expr_stub_14
">>"
:STRING_additive_expr_stub_16
"ADD_ebx_to_eax
"
:STRING_additive_expr_stub_17
"+"
:STRING_additive_expr_stub_18
"SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
"
:STRING_additive_expr_stub_19
"-"
:STRING_additive_expr_stub_20
"MULTIPLY_eax_by_ebx_into_eax
"
:STRING_additive_expr_stub_21
"*"
:STRING_additive_expr_stub_22
"XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
DIVIDE_eax_by_ebx_into_eax
"
:STRING_additive_expr_stub_23
"/"
:STRING_additive_expr_stub_24
"XCHG_eax_ebx
LOAD_IMMEDIATE_edx %0
MODULUS_eax_from_ebx_into_ebx
MOVE_edx_to_eax
"
:STRING_additive_expr_stub_25
"%"
:STRING_additive_expr_stub_26
"COPY_eax_to_ecx
COPY_ebx_to_eax
SAL_eax_cl
"
:STRING_additive_expr_stub_27
"<<"
:STRING_additive_expr_stub_28
"COPY_eax_to_ecx
COPY_ebx_to_eax
SAR_eax_cl
"
:STRING_additive_expr_stub_29
">>"
:STRING_additive_expr_stub_31
"ADD_rbx_to_rax
"
:STRING_additive_expr_stub_32
"+"
:STRING_additive_expr_stub_33
"SUBTRACT_rax_from_rbx_into_rbx
MOVE_rbx_to_rax
"
:STRING_additive_expr_stub_34
"-"
:STRING_additive_expr_stub_35
"MULTIPLY_rax_by_rbx_into_rax
"
:STRING_additive_expr_stub_36
"*"
:STRING_additive_expr_stub_37
"XCHG_rax_rbx
LOAD_IMMEDIATE_rdx %0
DIVIDE_rax_by_rbx_into_rax
"
:STRING_additive_expr_stub_38
"/"
:STRING_additive_expr_stub_39
"XCHG_rax_rbx
LOAD_IMMEDIATE_rdx %0
MODULUS_rax_from_rbx_into_rbx
MOVE_rdx_to_rax
"
:STRING_additive_expr_stub_40
"%"
:STRING_additive_expr_stub_41
"COPY_rax_to_rcx
COPY_rbx_to_rax
SAL_rax_cl
"
:STRING_additive_expr_stub_42
"<<"
:STRING_additive_expr_stub_43
"COPY_rax_to_rcx
COPY_rbx_to_rax
SAR_rax_cl
"
:STRING_additive_expr_stub_44
">>"
:STRING_additive_expr_stub_46
"'0' R0 R0 ADD R1 ARITH2_ALWAYS
"
:STRING_additive_expr_stub_47
"+"
:STRING_additive_expr_stub_48
"'0' R0 R0 SUB R1 ARITH2_ALWAYS
"
:STRING_additive_expr_stub_49
"-"
:STRING_additive_expr_stub_50
"'9' R0 '0' R1 MUL R0 ARITH2_ALWAYS
"
:STRING_additive_expr_stub_51
"*"
:STRING_additive_expr_stub_52
"{LR} PUSH_ALWAYS
^~divide CALL_ALWAYS
{LR} POP_ALWAYS
"
:STRING_additive_expr_stub_53
"/"
:STRING_additive_expr_stub_54
"{LR} PUSH_ALWAYS
^~modulus CALL_ALWAYS
{LR} POP_ALWAYS
"
:STRING_additive_expr_stub_55
"%"
:STRING_additive_expr_stub_56
"LEFT R1 R0 R0 SHIFT AUX_ALWAYS
"
:STRING_additive_expr_stub_57
"<<"
:STRING_additive_expr_stub_58
"RIGHT R1 R0 R0 SHIFT AUX_ALWAYS
"
:STRING_additive_expr_stub_59
">>"
:STRING_relational_expr_stub_1
"CMPSKIP.GE R1 R0
LOADUI R2 1
MOVE R0 R2
"
:STRING_relational_expr_stub_2
"<"
:STRING_relational_expr_stub_3
"CMPSKIP.G R1 R0
LOADUI R2 1
MOVE R0 R2
"
:STRING_relational_expr_stub_4
"<="
:STRING_relational_expr_stub_5
"CMPSKIP.L R1 R0
LOADUI R2 1
MOVE R0 R2
"
:STRING_relational_expr_stub_6
">="
:STRING_relational_expr_stub_7
"CMPSKIP.LE R1 R0
LOADUI R2 1
MOVE R0 R2
"
:STRING_relational_expr_stub_8
">"
:STRING_relational_expr_stub_9
"CMPSKIP.NE R1 R0
LOADUI R2 1
MOVE R0 R2
"
:STRING_relational_expr_stub_10
"=="
:STRING_relational_expr_stub_11
"CMPSKIP.E R1 R0
LOADUI R2 1
MOVE R0 R2
"
:STRING_relational_expr_stub_12
"!="
:STRING_relational_expr_stub_14
"CMP
SETL
MOVEZBL
"
:STRING_relational_expr_stub_15
"<"
:STRING_relational_expr_stub_16
"CMP
SETLE
MOVEZBL
"
:STRING_relational_expr_stub_17
"<="
:STRING_relational_expr_stub_18
"CMP
SETGE
MOVEZBL
"
:STRING_relational_expr_stub_19
">="
:STRING_relational_expr_stub_20
"CMP
SETG
MOVEZBL
"
:STRING_relational_expr_stub_21
">"
:STRING_relational_expr_stub_22
"CMP
SETE
MOVEZBL
"
:STRING_relational_expr_stub_23
"=="
:STRING_relational_expr_stub_24
"CMP
SETNE
MOVEZBL
"
:STRING_relational_expr_stub_25
"!="
:STRING_relational_expr_stub_27
"CMP
SETL
MOVEZX
"
:STRING_relational_expr_stub_28
"<"
:STRING_relational_expr_stub_29
"CMP
SETLE
MOVEZX
"
:STRING_relational_expr_stub_30
"<="
:STRING_relational_expr_stub_31
"CMP
SETGE
MOVEZX
"
:STRING_relational_expr_stub_32
">="
:STRING_relational_expr_stub_33
"CMP
SETG
MOVEZX
"
:STRING_relational_expr_stub_34
">"
:STRING_relational_expr_stub_35
"CMP
SETE
MOVEZX
"
:STRING_relational_expr_stub_36
"=="
:STRING_relational_expr_stub_37
"CMP
SETNE
MOVEZX
"
:STRING_relational_expr_stub_38
"!="
:STRING_relational_expr_stub_40
"'0' R0 CMP R1 AUX_ALWAYS
!0 R0 LOADI8_ALWAYS
!1 R0 LOADI8_L
"
:STRING_relational_expr_stub_41
"<"
:STRING_relational_expr_stub_42
"'0' R0 CMP R1 AUX_ALWAYS
!0 R0 LOADI8_ALWAYS
!1 R0 LOADI8_LE
"
:STRING_relational_expr_stub_43
"<="
:STRING_relational_expr_stub_44
"'0' R0 CMP R1 AUX_ALWAYS
!0 R0 LOADI8_ALWAYS
!1 R0 LOADI8_GE
"
:STRING_relational_expr_stub_45
">="
:STRING_relational_expr_stub_46
"'0' R0 CMP R1 AUX_ALWAYS
!0 R0 LOADI8_ALWAYS
!1 R0 LOADI8_G
"
:STRING_relational_expr_stub_47
">"
:STRING_relational_expr_stub_48
"'0' R0 CMP R1 AUX_ALWAYS
!0 R0 LOADI8_ALWAYS
!1 R0 LOADI8_EQUAL
"
:STRING_relational_expr_stub_49
"=="
:STRING_relational_expr_stub_50
"'0' R0 CMP R1 AUX_ALWAYS
!0 R0 LOADI8_ALWAYS
!1 R0 LOADI8_NE
"
:STRING_relational_expr_stub_51
"!="
:STRING_bitwise_expr_stub_1
"AND R0 R0 R1
"
:STRING_bitwise_expr_stub_2
"&"
:STRING_bitwise_expr_stub_3
"AND R0 R0 R1
"
:STRING_bitwise_expr_stub_4
"&&"
:STRING_bitwise_expr_stub_5
"OR R0 R0 R1
"
:STRING_bitwise_expr_stub_6
"|"
:STRING_bitwise_expr_stub_7
"OR R0 R0 R1
"
:STRING_bitwise_expr_stub_8
"||"
:STRING_bitwise_expr_stub_9
"XOR R0 R0 R1
"
:STRING_bitwise_expr_stub_10
"^"
:STRING_bitwise_expr_stub_12
"AND_eax_ebx
"
:STRING_bitwise_expr_stub_13
"&"
:STRING_bitwise_expr_stub_14
"AND_eax_ebx
"
:STRING_bitwise_expr_stub_15
"&&"
:STRING_bitwise_expr_stub_16
"OR_eax_ebx
"
:STRING_bitwise_expr_stub_17
"|"
:STRING_bitwise_expr_stub_18
"OR_eax_ebx
"
:STRING_bitwise_expr_stub_19
"||"
:STRING_bitwise_expr_stub_20
"XOR_ebx_eax_into_eax
"
:STRING_bitwise_expr_stub_21
"^"
:STRING_bitwise_expr_stub_23
"AND_rax_rbx
"
:STRING_bitwise_expr_stub_24
"&"
:STRING_bitwise_expr_stub_25
"AND_rax_rbx
"
:STRING_bitwise_expr_stub_26
"&&"
:STRING_bitwise_expr_stub_27
"OR_rax_rbx
"
:STRING_bitwise_expr_stub_28
"|"
:STRING_bitwise_expr_stub_29
"OR_rax_rbx
"
:STRING_bitwise_expr_stub_30
"||"
:STRING_bitwise_expr_stub_31
"XOR_rbx_rax_into_rax
"
:STRING_bitwise_expr_stub_32
"^"
:STRING_bitwise_expr_stub_34
"NO_SHIFT R0 R0 AND R1 ARITH2_ALWAYS
"
:STRING_bitwise_expr_stub_35
"&"
:STRING_bitwise_expr_stub_36
"NO_SHIFT R0 R0 AND R1 ARITH2_ALWAYS
"
:STRING_bitwise_expr_stub_37
"&&"
:STRING_bitwise_expr_stub_38
"NO_SHIFT R0 R0 OR R1 AUX_ALWAYS
"
:STRING_bitwise_expr_stub_39
"|"
:STRING_bitwise_expr_stub_40
"NO_SHIFT R0 R0 OR R1 AUX_ALWAYS
"
:STRING_bitwise_expr_stub_41
"||"
:STRING_bitwise_expr_stub_42
"'0' R0 R0 XOR R1 ARITH2_ALWAYS
"
:STRING_bitwise_expr_stub_43
"^"
:STRING_primary_expr_1
"&"
:STRING_primary_expr_3
"sizeof"
:STRING_primary_expr_6
"LOAD_IMMEDIATE_eax %0
"
:STRING_primary_expr_8
"LOAD_IMMEDIATE_rax %0
"
:STRING_primary_expr_10
"!0 R0 LOADI8_ALWAYS
"
:STRING_primary_expr_12
"NEG R0 R0
"
:STRING_primary_expr_14
"SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
"
:STRING_primary_expr_16
"SUBTRACT_rax_from_rbx_into_rbx
MOVE_rbx_to_rax
"
:STRING_primary_expr_18
"'0' R0 R0 SUB R1 ARITH2_ALWAYS
"
:STRING_primary_expr_21
"LOAD_IMMEDIATE_eax %1
"
:STRING_primary_expr_23
"LOAD_IMMEDIATE_rax %1
"
:STRING_primary_expr_25
"!1 R0 LOADI8_ALWAYS
"
:STRING_primary_expr_27
"XORI R0 R0 1
"
:STRING_primary_expr_29
"XOR_ebx_eax_into_eax
"
:STRING_primary_expr_31
"XOR_rbx_rax_into_rax
"
:STRING_primary_expr_33
"'0' R0 R0 XOR R1 ARITH2_ALWAYS
"
:STRING_primary_expr_36
"NOT R0 R0
"
:STRING_primary_expr_38
"NOT_eax
"
:STRING_primary_expr_40
"NOT_rax
"
:STRING_primary_expr_42
"'0' R0 R0 MVN_ALWAYS
"
:STRING_primary_expr_44
"Error in Primary expression
Didn't get )
"
:STRING_primary_expr_45
")"
:STRING_primary_expr_49
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
:STRING_primary_expr_51
"0123456789"
:STRING_expression_1
"="
:STRING_expression_2
""
:STRING_expression_4
"]"
:STRING_expression_5
"char*"
:STRING_expression_7
"STORE R0 R1 0
"
:STRING_expression_9
"STORE_INTEGER
"
:STRING_expression_11
"STORE_INTEGER
"
:STRING_expression_13
"!0 R0 STORE32 R1 MEMORY
"
:STRING_expression_15
"STORE8 R0 R1 0
"
:STRING_expression_17
"STORE_CHAR
"
:STRING_expression_19
"STORE_CHAR
"
:STRING_expression_21
"!0 R0 STORE8 R1 MEMORY
"
:STRING_collect_local_1
"main"
:STRING_collect_local_21
"# Defining local "
:STRING_collect_local_22
"
"
:STRING_collect_local_24
"="
:STRING_collect_local_25
"ERROR in collect_local
Missing ;
"
:STRING_collect_local_26
";"
:STRING_collect_local_28
"PUSHR R0 R15	#"
:STRING_collect_local_30
"PUSH_eax	#"
:STRING_collect_local_32
"PUSH_RAX	#"
:STRING_collect_local_34
"{R0} PUSH_ALWAYS	#"
:STRING_collect_local_35
"
"
:STRING_process_if_0
"# IF_"
:STRING_process_if_1
"ERROR in process_if
MISSING (
"
:STRING_process_if_2
"("
:STRING_process_if_4
"JUMP.Z R0 @ELSE_"
:STRING_process_if_6
"TEST
JUMP_EQ %ELSE_"
:STRING_process_if_8
"TEST
JUMP_EQ %ELSE_"
:STRING_process_if_10
"!0 CMPI8 R0 IMM_ALWAYS
^~ELSE_"
:STRING_process_if_12
" JUMP_EQUAL
"
:STRING_process_if_13
"ERROR in process_if
MISSING )
"
:STRING_process_if_14
")"
:STRING_process_if_16
"JUMP @_END_IF_"
:STRING_process_if_18
"JUMP %_END_IF_"
:STRING_process_if_20
"JUMP %_END_IF_"
:STRING_process_if_22
"^~_END_IF_"
:STRING_process_if_24
" JUMP_ALWAYS
"
:STRING_process_if_25
":ELSE_"
:STRING_process_if_27
"else"
:STRING_process_if_28
":_END_IF_"
:STRING_process_for_0
"FOR_END_"
:STRING_process_for_1
"# FOR_initialization_"
:STRING_process_for_2
"ERROR in process_for
MISSING (
"
:STRING_process_for_3
"("
:STRING_process_for_5
";"
:STRING_process_for_6
":FOR_"
:STRING_process_for_7
"ERROR in process_for
MISSING ;1
"
:STRING_process_for_8
";"
:STRING_process_for_10
"JUMP.Z R0 @FOR_END_"
:STRING_process_for_12
"TEST
JUMP_EQ %FOR_END_"
:STRING_process_for_14
"TEST
JUMP_EQ %FOR_END_"
:STRING_process_for_16
"!0 CMPI8 R0 IMM_ALWAYS
^~FOR_END_"
:STRING_process_for_18
" JUMP_EQUAL
"
:STRING_process_for_20
"JUMP @FOR_THEN_"
:STRING_process_for_22
"JUMP %FOR_THEN_"
:STRING_process_for_24
"JUMP %FOR_THEN_"
:STRING_process_for_26
"^~FOR_THEN_"
:STRING_process_for_28
" JUMP_ALWAYS
"
:STRING_process_for_29
":FOR_ITER_"
:STRING_process_for_30
"ERROR in process_for
MISSING ;2
"
:STRING_process_for_31
";"
:STRING_process_for_33
"JUMP @FOR_"
:STRING_process_for_35
"JUMP %FOR_"
:STRING_process_for_37
"JUMP %FOR_"
:STRING_process_for_39
"^~FOR_"
:STRING_process_for_41
" JUMP_ALWAYS
"
:STRING_process_for_42
":FOR_THEN_"
:STRING_process_for_43
"ERROR in process_for
MISSING )
"
:STRING_process_for_44
")"
:STRING_process_for_46
"JUMP @FOR_ITER_"
:STRING_process_for_48
"JUMP %FOR_ITER_"
:STRING_process_for_50
"JUMP %FOR_ITER_"
:STRING_process_for_52
"^~FOR_ITER_"
:STRING_process_for_54
" JUMP_ALWAYS
"
:STRING_process_for_55
":FOR_END_"
:STRING_process_asm_0
"ERROR in process_asm
MISSING (
"
:STRING_process_asm_1
"("
:STRING_process_asm_3
"
"
:STRING_process_asm_4
"ERROR in process_asm
MISSING )
"
:STRING_process_asm_5
")"
:STRING_process_asm_6
"ERROR in process_asm
MISSING ;
"
:STRING_process_asm_7
";"
:STRING_process_do_0
"DO_END_"
:STRING_process_do_1
":DO_"
:STRING_process_do_2
"ERROR in process_do
MISSING while
"
:STRING_process_do_3
"while"
:STRING_process_do_4
"ERROR in process_do
MISSING (
"
:STRING_process_do_5
"("
:STRING_process_do_6
"ERROR in process_do
MISSING )
"
:STRING_process_do_7
")"
:STRING_process_do_8
"ERROR in process_do
MISSING ;
"
:STRING_process_do_9
";"
:STRING_process_do_11
"JUMP.NZ R0 @DO_"
:STRING_process_do_13
"TEST
JUMP_NE %DO_"
:STRING_process_do_15
"TEST
JUMP_NE %DO_"
:STRING_process_do_17
"!0 CMPI8 R0 IMM_ALWAYS
^~DO_"
:STRING_process_do_19
" JUMP_NE
"
:STRING_process_do_20
":DO_END_"
:STRING_process_while_0
"END_WHILE_"
:STRING_process_while_1
":WHILE_"
:STRING_process_while_2
"ERROR in process_while
MISSING (
"
:STRING_process_while_3
"("
:STRING_process_while_5
"JUMP.Z R0 @END_WHILE_"
:STRING_process_while_7
"TEST
JUMP_EQ %END_WHILE_"
:STRING_process_while_9
"TEST
JUMP_EQ %END_WHILE_"
:STRING_process_while_11
"!0 CMPI8 R0 IMM_ALWAYS
^~END_WHILE_"
:STRING_process_while_13
" JUMP_EQUAL	"
:STRING_process_while_14
"# THEN_while_"
:STRING_process_while_15
"ERROR in process_while
MISSING )
"
:STRING_process_while_16
")"
:STRING_process_while_18
"JUMP @WHILE_"
:STRING_process_while_20
"JUMP %WHILE_"
:STRING_process_while_22
"JUMP %WHILE_"
:STRING_process_while_24
"^~WHILE_"
:STRING_process_while_26
" JUMP_ALWAYS
"
:STRING_process_while_27
":END_WHILE_"
:STRING_return_result_1
"ERROR in return_result
MISSING ;
"
:STRING_return_result_2
";"
:STRING_return_result_5
"POPR R1 R15	# _return_result_locals
"
:STRING_return_result_7
"POP_ebx	# _return_result_locals
"
:STRING_return_result_9
"POP_RBX	# _return_result_locals
"
:STRING_return_result_11
"{R1} POP_ALWAYS	# _return_result_locals
"
:STRING_return_result_13
"RET R15
"
:STRING_return_result_15
"RETURN
"
:STRING_return_result_17
"RETURN
"
:STRING_return_result_19
"'1' LR RETURN
"
:STRING_process_break_1
"Not inside of a loop or case statement"
:STRING_process_break_5
"POPR R1 R15	# break_cleanup_locals
"
:STRING_process_break_7
"POP_ebx	# break_cleanup_locals
"
:STRING_process_break_9
"POP_RBX	# break_cleanup_locals
"
:STRING_process_break_11
"{R1} POP_ALWAYS	# break_cleanup_locals
"
:STRING_process_break_13
"JUMP @"
:STRING_process_break_15
"JUMP %"
:STRING_process_break_17
"JUMP %"
:STRING_process_break_19
"^~"
:STRING_process_break_20
"_"
:STRING_process_break_22
" JUMP_ALWAYS"
:STRING_process_break_23
"
"
:STRING_process_break_24
"ERROR in break statement
Missing ;
"
:STRING_process_break_25
";"
:STRING_recursive_statement_1
"}"
:STRING_recursive_statement_3
"RETURN
"
:STRING_recursive_statement_4
"RETURN
"
:STRING_recursive_statement_5
"RET R15
"
:STRING_recursive_statement_6
"'1' LR RETURN
"
:STRING_recursive_statement_9
"POPR R1 R15	# _recursive_statement_locals
"
:STRING_recursive_statement_11
"POP_ebx	# _recursive_statement_locals
"
:STRING_recursive_statement_13
"POP_RBX	# _recursive_statement_locals
"
:STRING_recursive_statement_15
"{R1} POP_ALWAYS	# _recursive_statement_locals
"
:STRING_statement_2
"	#C goto label
"
:STRING_statement_4
"struct"
:STRING_statement_6
"if"
:STRING_statement_8
"do"
:STRING_statement_10
"while"
:STRING_statement_12
"for"
:STRING_statement_14
"asm"
:STRING_statement_16
"goto"
:STRING_statement_18
"JUMP @"
:STRING_statement_20
"JUMP %"
:STRING_statement_22
"JUMP %"
:STRING_statement_24
"^~"
:STRING_statement_26
" JUMP_ALWAYS"
:STRING_statement_27
"
"
:STRING_statement_28
"ERROR in statement
Missing ;
"
:STRING_statement_29
";"
:STRING_statement_31
"return"
:STRING_statement_33
"break"
:STRING_statement_35
"continue"
:STRING_statement_36
"
#continue statement
"
:STRING_statement_37
"ERROR in statement
Missing ;
"
:STRING_statement_38
";"
:STRING_statement_39
"ERROR in statement
MISSING ;
"
:STRING_statement_40
";"
:STRING_collect_arguments_1
")"
:STRING_declare_function_1
"main"
:STRING_declare_function_2
"Impossible error ( vanished
"
:STRING_declare_function_3
"("
:STRING_declare_function_4
"Reality ERROR (USING KNIGHT-NATIVE)
Hardware does not support arguments
thus neither can main on this architecture
try tape_01 and tape_02 instead
"
:STRING_declare_function_5
")"
:STRING_declare_function_7
"# Defining function "
:STRING_declare_function_8
"
"
:STRING_declare_function_9
":FUNCTION_"
:STRING_declare_function_10
"
"
:STRING_declare_function_12
"RET R15
"
:STRING_declare_function_13
"RET R15
"
:STRING_declare_function_15
"RETURN
"
:STRING_declare_function_16
"RETURN
"
:STRING_declare_function_18
"RETURN
"
:STRING_declare_function_19
"RETURN
"
:STRING_declare_function_21
"'1' LR RETURN
"
:STRING_declare_function_22
"'1' LR RETURN
"
:STRING_program_2
"CONSTANT"
:STRING_program_4
"sizeof"
:STRING_program_5
"ERROR in CONSTANT with sizeof
Missing (
"
:STRING_program_6
"("
:STRING_program_7
"ERROR in CONSTANT with sizeof
Missing )
"
:STRING_program_8
")"
:STRING_program_11
";"
:STRING_program_12
":GLOBAL_"
:STRING_program_13
"
NOP
"
:STRING_program_15
"("
:STRING_program_17
"="
:STRING_program_18
":GLOBAL_"
:STRING_program_19
"
"
:STRING_program_21
"0123456789"
:STRING_program_22
"%"
:STRING_program_23
"
"
:STRING_program_25
"&GLOBAL_"
:STRING_program_26
"_contents
"
:STRING_program_27
":GLOBAL_"
:STRING_program_28
"_contents
"
:STRING_program_29
"Recieved "
:STRING_program_30
" in program
"
:STRING_program_31
"ERROR in Program
Missing ;
"
:STRING_program_32
";"
:STRING_program_33
"Recieved "
:STRING_program_34
" in program
"
:STRING_main_3
"-f"
:STRING_main_4
"--file"
:STRING_main_5
"r"
:STRING_main_7
"Unable to open for reading file: "
:STRING_main_8
"
 Aborting to avoid problems
"
:STRING_main_10
"-o"
:STRING_main_11
"--output"
:STRING_main_12
"w"
:STRING_main_14
"Unable to open for writing file: "
:STRING_main_15
"
 Aborting to avoid problems
"
:STRING_main_17
"-A"
:STRING_main_18
"--architecture"
:STRING_main_20
"knight-native"
:STRING_main_22
"knight-posix"
:STRING_main_24
"x86"
:STRING_main_26
"amd64"
:STRING_main_28
"armv7l"
:STRING_main_29
"Unknown architecture: "
:STRING_main_30
" know values are: knight-native, knight-posix, x86, amd64 and armv7l"
:STRING_main_32
"-g"
:STRING_main_33
"--debug"
:STRING_main_35
"-h"
:STRING_main_36
"--help"
:STRING_main_37
" -f input file
 -o output file
 --help for this message
 --version for file version
"
:STRING_main_39
"-V"
:STRING_main_40
"--version"
:STRING_main_41
"M2-Planet v1.3.0
"
:STRING_main_42
"UNKNOWN ARGUMENT
"
:STRING_main_44
"STDIN"
:STRING_main_46
"Either no input files were given or they were empty
"
:STRING_main_47
"
# Core program
"
:STRING_main_49
"
"
:STRING_main_51
' 0A 3A 45 4C 46 5F 64 61 74 61 0A 00'
:STRING_main_52
"
# Program global variables
"
:STRING_main_53
"
# Program strings
"
:STRING_main_55
' 0A 3A 53 54 41 43 4B 0A 00'
:STRING_main_57
' 0A 3A 45 4C 46 5F 65 6E 64 0A 00'

:ELF_end
