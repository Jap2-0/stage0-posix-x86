# SPDX-FileCopyrightText: Â© 2017 Jeremiah Orians
#
# SPDX-License-Identifier: GPL-3.0-or-later

	# Register usage:
	# EAX, ECX, EBX => Temps
	# EDI => MALLOC
	# EBP => HEAD
	# [Output] => Output_file
	# [Input] => Input_file

	# Struct format: (size 32)
	# NEXT => 0
	# TYPE => 8
	# TEXT => 16
	# EXPRESSION => 24

	# Types
	# None => 0
	# MACRO => 1
	# STRING => 2

# Where the ELF Header is going to hit
# Simply jump to _start
# Our main function

:_start
	58                          ; pop_eax                     # Get the number of arguments
	5B                          ; pop_ebx                     # Get the program name
	5B                          ; pop_ebx                     # Get the actual input name
	B9 00000000                 ; mov_ecx, %0                 # prepare read_only
	B8 05000000                 ; mov_eax, %5                 # the syscall number for open()
	CD 80                       ; int !0x80                   # Now open that damn file
	A3 &Input                   ; mov_[DWORD],eax &Input      # Preserve the file pointer we were given

	5B                          ; pop_ebx                     # Get the actual output name
	B9 41020000                 ; mov_ecx, %577               # Prepare file as O_WRONLY|O_CREAT|O_TRUNC
	BA 80010000                 ; mov_edx, %384               # Prepare file as RW for owner only (600 in octal)
	B8 05000000                 ; mov_eax, %5                 # the syscall number for open()
	CD 80                       ; int !0x80                   # Now open that damn file
	83F8 00                     ; cmp_eax, !0                 # Check for missing output
	0F8F %_start_out            ; jg %_start_out              # Have real input
	B8 01000000                 ; mov_eax, %1                 # Use stdout

:_start_out
	A3 &Output                  ; mov_[DWORD],eax &Output     # Preserve the file pointer we were given

	B8 2D000000                 ; mov_eax, %45                # the Syscall # for SYS_BRK
	BB 00000000                 ; mov_ebx, %0                 # Get current brk
	CD 80                       ; int !0x80                   # Let the kernel do the work
	89C7                        ; mov_edi,eax                 # Set our malloc pointer

	E8 %Tokenize_Line           ; call %Tokenize_Line         # Get all lines
	89E8                        ; mov_eax,ebp                 # prepare for Reverse_List
	E8 %Reverse_List            ; call %Reverse_List          # Correct order
	89C5                        ; mov_ebp,eax                 # Update HEAD
	E8 %Identify_Macros         ; call %Identify_Macros       # Find the DEFINEs
	E8 %Line_Macro              ; call %Line_Macro            # Apply the DEFINEs
	E8 %Process_String          ; call %Process_String        # Handle strings
	E8 %Eval_Immediates         ; call %Eval_Immediates       # Handle Numbers
	E8 %Preserve_Other          ; call %Preserve_Other        # Collect the remaining
	E8 %Print_Hex               ; call %Print_Hex             # Output our results

:Done
	# program completed Successfully
	BB 00000000                 ; mov_ebx, %0                 # All is well
	B8 01000000                 ; mov_eax, %1                 # put the exit syscall number in eax
	CD 80                       ; int !0x80                   # Call it a good day


# Tokenize_Line Function
# Using input file [Input] and Head EBP
# Creates a linked list of structs
# Uses EBX for in_set strings, ECX for Int C and EDX for Struct Token* p
:Tokenize_Line
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
:restart
	E8 %fgetc                   ; call %fgetc                 # Read a char
	83F8 FC                     ; cmp_eax, !-4                # Check for EOF
	0F84 %done                  ; je %done                    # File is collected

	0FB6C0                      ; movzx_eax,al                # We have to zero extend it to use it
	89C1                        ; mov_ecx,eax                 # Protect C

	BB &comments                ; mov_ebx, &comments          # Get pointer to "#;"
	E8 %In_Set                  ; call %In_Set                # Check for comments
	83F8 01                     ; cmp_eax, !1                 # If comments
	0F84 %Purge_LineComment     ; je %Purge_LineComment       # try again

	89C8                        ; mov_eax,ecx                 # put C in place for check
	BB &terminators             ; mov_ebx, &terminators       # Get pointer to "\n\t "
	E8 %In_Set                  ; call %In_Set                # Check for terminators
	83F8 01                     ; cmp_eax, !1                 # If terminator
	0F84 %restart               ; je %restart                 # try again

	B8 20000000                 ; mov_eax, %32                # Malloc the struct P
	E8 %malloc                  ; call %malloc                # Get pointer to P
	89C2                        ; mov_edx,eax                 # Protect P
	892A                        ; mov_[edx],ebp               # P->NEXT = HEAD
	89D5                        ; mov_ebp,edx                 # HEAD = P

	89C8                        ; mov_eax,ecx                 # put C in place for check
	BB &string_char             ; mov_ebx, &string_char       # Get pointer to "\"'"
	E8 %In_Set                  ; call %In_Set                # Check for string chars
	83F8 01                     ; cmp_eax, !1                 # If string char
	0F84 %Store_String          ; je %Store_String            # Get string

	E8 %Store_Atom              ; call %Store_Atom            # Get whole token
	E9 %restart                 ; jmp %restart

:done
	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# fgetc function
# Receives FILE* in [Input]
# Returns -4 (EOF) or char in EAX
:fgetc
	52                          ; push_edx                    # Protect EDX
	51                          ; push_ecx                    # Protect ECX
	53                          ; push_ebx                    # Protect EBX
	B8 FCFFFFFF                 ; mov_eax, %-4                # Put EOF in eax
	50                          ; push_eax                    # Assume bad (If nothing read, value will remain EOF)
	8D0C24                      ; lea_ecx,[esp]               # Get stack address
	8B1D &Input                 ; mov_ebx,[DWORD] &Input      # Where are we reading from
	B8 03000000                 ; mov_eax, %3                 # the syscall number for read
	BA 01000000                 ; mov_edx, %1                 # set the size of chars we want
	CD 80                       ; int !0x80                   # call the Kernel
	58                          ; pop_eax                     # Get either char or EOF
	5B                          ; pop_ebx                     # Restore EBX
	59                          ; pop_ecx                     # Restore ECX
	5A                          ; pop_edx                     # Restore EDX
	C3                          ; ret


# Malloc isn't actually required if the program being built fits in the initial memory
# However, it doesn't take much to add it.
# Requires EDI to be initialized and EAX to have the number of desired bytes
:malloc
	52                          ; push_edx                    # Protect EDX
	51                          ; push_ecx                    # Protect ECX
	53                          ; push_ebx                    # Protect EBX

	89FB                        ; mov_ebx,edi                 # Using the current pointer
	01C3                        ; add_ebx,eax                 # Request the number of desired bytes
	B8 2D000000                 ; mov_eax, %45                # the Syscall # for SYS_BRK
	CD 80                       ; int !0x80                   # call the Kernel
	89F8                        ; mov_eax,edi                 # Return pointer
	89DF                        ; mov_edi,ebx                 # Update pointer

	5B                          ; pop_ebx                     # Restore EBX
	59                          ; pop_ecx                     # Restore ECX
	5A                          ; pop_edx                     # Restore EDX
	C3                          ; ret


# Purge_LineComment function
# Reads chars until LF and jumps to restart
:Purge_LineComment
	E8 %fgetc                   ; call %fgetc                 # Get a char
	0FB6C0                      ; movzx_eax,al                # Zero extend
	83F8 0A                     ; cmp_eax, !10                # While not LF
	0F85 %Purge_LineComment     ; jne %Purge_LineComment      # Keep reading
	E9 %restart                 ; jmp %restart


# Store_String Function
# Receives C in ECX, HEAD in EDX and Input file in [Output]
# Uses EBX for terminator, ECX for C and EDX for string
:Store_String
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX

	B8 02000000                 ; mov_eax, %2                 # Using TYPE STRING
	8942 08                     ; mov_[edx+BYTE],eax !8       # HEAD->TYPE = STRING
	B8 00010000                 ; mov_eax, %256               # Malloc the string
	E8 %malloc                  ; call %malloc                # Get pointer to P
	8942 10                     ; mov_[edx+BYTE],eax !16      # HEAD->TEXT = STRING
	89CB                        ; mov_ebx,ecx                 # Protect terminator
	89C2                        ; mov_edx,eax                 # Protect string pointer
:Store_String_Loop
	880A                        ; mov_[edx],cl                # write byte
	E8 %fgetc                   ; call %fgetc                 # read next char
	0FB6C0                      ; movzx_eax,al                # Zero extend it
	89C1                        ; mov_ecx,eax                 # Update C
	83C2 01                     ; add_edx, !1                 # STRING = STRING + 1
	39D9                        ; cmp_ebx,ecx                 # See if we hit terminator
	0F85 %Store_String_Loop     ; jne %Store_String_Loop      # Otherwise keep looping

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	89D0                        ; mov_eax,edx                 # return HEAD
	E9 %restart                 ; jmp %restart


# Store_Atom Function
# Receives C in ECX, HEAD in EDX and Input file in [Input]
# Uses EBX for in_set strings, ECX for C and EDX for string
:Store_Atom
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX

	B8 00010000                 ; mov_eax, %256               # Malloc the string
	E8 %malloc                  ; call %malloc                # Get pointer to P
	8942 10                     ; mov_[edx+BYTE],eax !16      # HEAD->TEXT = STRING
	BB &terminators             ; mov_ebx, &terminators       # Get pointer to "\n\t "
	89C2                        ; mov_edx,eax                 # Protect string pointer
:Store_Atom_loop
	880A                        ; mov_[edx],cl                # write byte
	E8 %fgetc                   ; call %fgetc                 # read next char
	0FB6C0                      ; movzx_eax,al                # Zero extend it
	89C1                        ; mov_ecx,eax                 # Update C
	83C2 01                     ; add_edx, !1                 # STRING = STRING + 1
	E8 %In_Set                  ; call %In_Set                # Check for terminators
	83F8 00                     ; cmp_eax, !0                 # Check for "\n\t "
	0F84 %Store_Atom_loop       ; je %Store_Atom_loop         # Loop otherwise

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	89D0                        ; mov_eax,edx                 # return HEAD
	C3                          ; ret


# In_Set function
# Receives Char C in EAX and CHAR* in EBX
# Returns 1 if true, zero if false in EAX
:In_Set
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
:In_Set_loop
	8A0B                        ; mov_cl,[ebx]                # Read char
	0FB6C9                      ; movzx_ecx,cl                # Zero extend it

	39C8                        ; cmp_eax,ecx                 # See if they match
	0F84 %In_Set_True           ; je %In_Set_True             # return true

	83F9 00                     ; cmp_ecx, !0                 # Check for NULL
	0F84 %In_Set_False          ; je %In_Set_False            # return false

	83C3 01                     ; add_ebx, !1                 # s = s + 1
	E9 %In_Set_loop             ; jmp %In_Set_loop            # Keep looping

:In_Set_True
	B8 01000000                 ; mov_eax, %1                 # Set True
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret

:In_Set_False
	B8 00000000                 ; mov_eax, %0                 # Set FALSE
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret

# Char sets
:terminators
0A 09 20 00                         ; "\n\t "

:comments
3B 23 00                            ; ";#"

:string_char
22 27 00                            ; "\"\'"


# Reverse_List function
# Receives List in EAX
# Returns the list reversed in EAX
:Reverse_List
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	89C3                        ; mov_ebx,eax                 # Set HEAD
	B8 00000000                 ; mov_eax, %0                 # ROOT = NULL
:Reverse_List_Loop
	83FB 00                     ; cmp_ebx, !0                 # WHILE HEAD != NULL
	0F84 %Reverse_List_Done     ; je %Reverse_List_Done       # Stop otherwise

	8B0B                        ; mov_ecx,[ebx]               # NEXT = HEAD->NEXT
	8903                        ; mov_[ebx],eax               # HEAD->NEXT = ROOT
	89D8                        ; mov_eax,ebx                 # ROOT = HEAD
	89CB                        ; mov_ebx,ecx                 # HEAD = NEXT
	E9 %Reverse_List_Loop       ; jmp %Reverse_List_Loop      # Keep Going

:Reverse_List_Done
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# Identify_Macros function
# Receives List in EAX
# Updates the list in place; does not modify registers
# Uses EBX for DEFINE, ECX for I
:Identify_Macros
	50                          ; push_eax                    # Protect EAX
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	BB &DEFINE_str              ; mov_ebx, &DEFINE_str        # Setup define string
	89C1                        ; mov_ecx,eax                 # I = HEAD
:Identify_Macros_Loop
	8B41 10                     ; mov_eax,[ecx+BYTE] !16      # I->TEXT
	E8 %match                   ; call %match                 # IF "DEFINE" == I->TEXT
	83F8 00                     ; cmp_eax, !0                 # Check if match
	0F85 %Identify_Macros_Next  ; jne %Identify_Macros_Next   # Skip the work

	# Deal with MACRO
	B8 01000000                 ; mov_eax, %1                 # Using MACRO
	8941 08                     ; mov_[ecx+BYTE],eax !8       # I->TYPE = MACRO

	8B01                        ; mov_eax,[ecx]               # I->NEXT
	8B40 10                     ; mov_eax,[eax+BYTE] !16      # I->NEXT->TEXT
	8941 10                     ; mov_[ecx+BYTE],eax !16      # I->TEXT = I->NEXT->TEXT

	8B01                        ; mov_eax,[ecx]               # I->NEXT
	8B00                        ; mov_eax,[eax]               # I->NEXT->NEXT
	8B40 10                     ; mov_eax,[eax+BYTE] !16      # I->NEXT->NEXT->TEXT
	8941 18                     ; mov_[ecx+BYTE],eax !24      # I->EXPRESSION = I->NEXT->NEXT->TEXT

	8B01                        ; mov_eax,[ecx]               # I->NEXT
	8B00                        ; mov_eax,[eax]               # I->NEXT->NEXT
	8B00                        ; mov_eax,[eax]               # I->NEXT->NEXT->NEXT
	8901                        ; mov_[ecx],eax               # I->NEXT = I->NEXT->NEXT->NEXT

:Identify_Macros_Next
	8B09                        ; mov_ecx,[ecx]               # I = I->NEXT
	83F9 00                     ; cmp_ecx, !0                 # Check for NULL
	0F85 %Identify_Macros_Loop  ; jne %Identify_Macros_Loop   # Keep looping otherwise

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	58                          ; pop_eax                     # Restore EAX
	C3                          ; ret

:DEFINE_str
44 45 46 49 4E 45 00                ; "DEFINE"


# match function
# Receives CHAR* in EAX and CHAR* in EBX
# Returns 0 (TRUE) or 1 (FALSE) in EAX
:match
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	89C1                        ; mov_ecx,eax                 # S1 in place
	89DA                        ; mov_edx,ebx                 # S2 in place
:match_Loop
	8A01                        ; mov_al,[ecx]                # S1[0]
	0FB6C0                      ; movzx_eax,al                # Make it useful
	8A1A                        ; mov_bl,[edx]                # S2[0]
	0FB6DB                      ; movzx_ebx,bl                # Make it useful
	39D8                        ; cmp_eax,ebx                 # See if they match
	0F85 %match_False           ; jne %match_False            # If not

	83C1 01                     ; add_ecx, !1                 # S1 = S1 + 1
	83C2 01                     ; add_edx, !1                 # S2 = S2 + 1
	83F8 00                     ; cmp_eax, !0                 # If reached end of string
	0F84 %match_Done            ; je %match_Done              # Perfect match
	E9 %match_Loop              ; jmp %match_Loop             # Otherwise keep looping

:match_False
	B8 01000000                 ; mov_eax, %1                 # Return false
:match_Done
	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# Line_Macro function
# Receives List in EAX
# Updates the list in place; does not modify registers
# Uses EAX for I, EBX for I->TEXT, ECX for I->EXPRESSION
:Line_Macro
	50                          ; push_eax                    # Protect EAX
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
:Line_Macro_Loop
	8B58 08                     ; mov_ebx,[eax+BYTE] !8       # I->TYPE
	83FB 01                     ; cmp_ebx, !1                 # IF MACRO == I->TYPE
	0F85 %Line_Macro_Next       ; jne %Line_Macro_Next        # Otherwise move on

	# Is a macro apply
	8B58 10                     ; mov_ebx,[eax+BYTE] !16      # I->TEXT
	8B48 18                     ; mov_ecx,[eax+BYTE] !24      # I->EXPRESSION
	8B00                        ; mov_eax,[eax]               # I->NEXT
	E8 %Set_Expression          ; call %Set_Expression        # Apply it
	E9 %Line_Macro_Loop         ; jmp %Line_Macro_Loop        # Move on to next

:Line_Macro_Next
	8B00                        ; mov_eax,[eax]               # I->NEXT
	83F8 00                     ; cmp_eax, !0                 # Check for NULL
	0F85 %Line_Macro_Loop       ; jne %Line_Macro_Loop        # Keep going

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	58                          ; pop_eax                     # Restore EAX
	C3                          ; ret


# Set_Expression function
# Receives List in EAX, CHAR* in EBX and CHAR* in ECX
# Updates the list in place; does not modify registers
# Uses EBX for C, ECX for EXP and EDX for I
:Set_Expression
	50                          ; push_eax                    # Protect EAX
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	89C2                        ; mov_edx,eax                 # Set I
:Set_Expression_Loop
	8B42 08                     ; mov_eax,[edx+BYTE] !8       # I->TYPE
	83F8 01                     ; cmp_eax, !1                 # IF MACRO == I->TYPE
	0F84 %Set_Expression_Next   ; je %Set_Expression_Next     # Ignore and move on

	8B42 10                     ; mov_eax,[edx+BYTE] !16      # I->TEXT
	E8 %match                   ; call %match                 # Check for match
	83F8 00                     ; cmp_eax, !0                 # If match
	0F85 %Set_Expression_Next   ; jne %Set_Expression_Next    # Otherwise next

	# We have a non-macro match
	894A 18                     ; mov_[edx+BYTE],ecx !24      # I->EXPRESSION = EXP

:Set_Expression_Next
	8B12                        ; mov_edx,[edx]               # I = I->NEXT
	83FA 00                     ; cmp_edx, !0                 # IF NULL == I
	0F85 %Set_Expression_Loop   ; jne %Set_Expression_Loop    # Otherwise keep looping

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	58                          ; pop_eax                     # Restore EAX
	C3                          ; ret


# Process_String function
# Receives List in EAX
# Update the list in place; does not modify registers
# Uses EBX for I->TEXT, ECX for I and EDX for S
:Process_String
	50                          ; push_eax                    # Protect EAX
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	89C1                        ; mov_ecx,eax                 # I = HEAD
:Process_String_loop
	8B41 08                     ; mov_eax,[ecx+BYTE] !8       # I->TYPE
	83F8 02                     ; cmp_eax, !2                 # IF STRING == I->TYPE
	0F85 %Process_String_Next   ; jne %Process_String_Next    # Skip to next

	8B59 10                     ; mov_ebx,[ecx+BYTE] !16      # I->TEXT
	8A03                        ; mov_al,[ebx]                # I->TEXT[0]
	0FB6C0                      ; movzx_eax,al                # make it useful
	83F8 27                     ; cmp_eax, !39                # IF '\'' == I->TEXT[0]
	0F85 %Process_String_Raw    ; jne %Process_String_Raw     # Deal with '\"'

	# Deal with '\''
	83C3 01                     ; add_ebx, !1                 # I->TEXT + 1
	8959 18                     ; mov_[ecx+BYTE],ebx !24      # I->EXPRESSION = I->TEXT + 1
	E9 %Process_String_Next     ; jmp %Process_String_Next    # Move on to next

:Process_String_Raw
	89D8                        ; mov_eax,ebx                 # Get length of I->TEXT
	E8 %string_length           ; call %string_length         # Do it
	C1E8 02                     ; shr_eax, !2                 # LENGTH = LENGTH >> 2
	83C0 01                     ; add_eax, !1                 # LENGTH = LENGTH + 1
	C1E0 03                     ; shl_eax, !3                 # LENGTH = LENGTH << 3
	E8 %malloc                  ; call %malloc                # Get string
	89DA                        ; mov_edx,ebx                 # S = I->TEXT
	83C2 01                     ; add_edx, !1                 # S = S + 1
	8941 18                     ; mov_[ecx+BYTE],eax !24      # I->EXPRESSION = hexify
	89C3                        ; mov_ebx,eax                 # Put hexify buffer in ebx

:Process_String_Raw_Loop
	8A02                        ; mov_al,[edx]                # Read 1 chars
	0FB6C0                      ; movzx_eax,al                # Make it useful
	83C2 01                     ; add_edx, !1                 # S = S + 1
	3C 00                       ; cmp_al, !0                  # Check for NULL
	9C                          ; pushf                       # Protect condition
	E8 %hex8                    ; call %hex8                  # write them all
	9D                          ; popf                        # restore condition
	0F85 %Process_String_Raw_Loop ; jne %Process_String_Raw_Loop # Keep looping

:Process_String_Next
	8B09                        ; mov_ecx,[ecx]               # I = I->NEXT
	83F9 00                     ; cmp_ecx, !0                 # IF NULL == I
	0F85 %Process_String_loop   ; jne %Process_String_loop    # Otherwise keep looping

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	58                          ; pop_eax                     # Restore EAX
	C3                          ; ret


# string_length function
# Receives CHAR* in EAX
# Returns INT in EAX
# Uses EAX for CH, EBX for S and ECX for INDEX
:string_length
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	89C3                        ; mov_ebx,eax                 # Set S
	B9 00000000                 ; mov_ecx, %0                 # INDEX = 0
:string_length_loop
	8A040B                      ; mov_al,[ebx+ecx]            # S[0]
	0FB6C0                      ; movzx_eax,al                # make it useful
	83F8 00                     ; cmp_eax, !0                 # IF NULL == S[0]
	0F84 %string_length_done    ; je %string_length_done      # Stop

	83C1 01                     ; add_ecx, !1                 # INDEX = INDEX + 1
	E9 %string_length_loop      ; jmp %string_length_loop     # Keep going

:string_length_done
	89C8                        ; mov_eax,ecx                 # RETURN INDEX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# Eval_Immediates function
# Receives List in EAX
# Updates the list in place; does not modify registers
# Uses EBX for I->TEXT[0], ECX for I->TEXT[1] and EDX for I
:Eval_Immediates
	50                          ; push_eax                    # Protect EAX
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	89C2                        ; mov_edx,eax                 # I = HEAD
:Eval_Immediates_Loop
	# Check for MACRO
	8B42 08                     ; mov_eax,[edx+BYTE] !8       # I->TYPE
	83F8 01                     ; cmp_eax, !1                 # IF MACRO == I-TYPE
	0F84 %Eval_Immediates_Next  ; je %Eval_Immediates_Next    # Skip to next

	# Check for NULL EXPRESSION
	8B42 18                     ; mov_eax,[edx+BYTE] !24      # I->EXPRESSION
	83F8 00                     ; cmp_eax, !0                 # IF NULL == I->EXPRESSION
	0F85 %Eval_Immediates_Next  ; jne %Eval_Immediates_Next   # Skip to next

	# Check if number
	8B42 10                     ; mov_eax,[edx+BYTE] !16      # I->TEXT
	8A18                        ; mov_bl,[eax]                # I->TEXT[0]
	0FB6DB                      ; movzx_ebx,bl                # Extend to use
	83C0 01                     ; add_eax, !1                 # I->TEXT + 1
	8A08                        ; mov_cl,[eax]                # I->TEXT[1]
	0FB6C9                      ; movzx_ecx,cl                # Extend to use
	E8 %numerate_string         ; call %numerate_string       # Convert string to INT
	83F8 00                     ; cmp_eax, !0                 # IF 0 == numerate_number(I->TEXT + 1)
	0F85 %Eval_Immediates_value ; jne %Eval_Immediates_value  # Has a value

	# Last chance for Immediate
	83F9 30                     ; cmp_ecx, !48                # If '0' == I->TEXT[1]
	0F85 %Eval_Immediates_Next  ; jne %Eval_Immediates_Next   # Skip to next

:Eval_Immediates_value
	E8 %express_number          ; call %express_number        # Convert value to hex string
	8942 18                     ; mov_[edx+BYTE],eax !24      # I->EXPRESSION = express_number(value, I-TEXT[0])

:Eval_Immediates_Next
	8B12                        ; mov_edx,[edx]               # I = I->NEXT
	83FA 00                     ; cmp_edx, !0                 # IF NULL == I
	0F85 %Eval_Immediates_Loop  ; jne %Eval_Immediates_Loop   # Otherwise keep looping

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	58                          ; pop_eax                     # Restore EAX
	C3                          ; ret


# numerate_string function
# Receives CHAR* in EAX
# Returns value of CHAR* in EAX
# Uses EAX for VALUE, EBX for S, ECX for CH and EDI for NEGATIVE?
:numerate_string
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	57                          ; push_edi                    # Protect EDI
	89C3                        ; mov_ebx,eax                 # put S in correct place
	B8 00000000                 ; mov_eax, %0                 # Initialize to Zero
:numerate_string_loop
	8A4B 01                     ; mov_cl,[ebx+BYTE] !1        # S[1]
	0FB6C9                      ; movzx_ecx,cl                # make it useful
	83F9 78                     ; cmp_ecx, !120               # IF 'x' == S[1]
	0F84 %numerate_hex          ; je %numerate_hex            # Deal with hex input

	# Assume decimal input
	B9 00000000                 ; mov_ecx, %0                 # Assume no negation
	8A0B                        ; mov_cl,[ebx]                # S[0]
	0FB6C9                      ; movzx_ecx,cl                # make it useful
	83F9 2D                     ; cmp_ecx, !45                # IF '-' == S[0]
	0F85 %numerate_decimal      ; jne %numerate_decimal       # Skip negation

	BF 01000000                 ; mov_edi, %1                 # Set FLAG
	83C3 01                     ; add_ebx, !1                 # S = S + 1

:numerate_decimal
	8A0B                        ; mov_cl,[ebx]                # S[0]
	0FB6C9                      ; movzx_ecx,cl                # make it useful
	83F9 00                     ; cmp_ecx, !0                 # IF NULL == S[0]
	0F84 %numerate_decimal_done ; je %numerate_decimal_done   # We are done

	6BC0 0A                     ; imul_eax, !10               # VALUE = VALUE * 10
	83E9 30                     ; sub_ecx, !48                # CH = CH - '0'
	83F9 09                     ; cmp_ecx, !9                 # Check for illegal
	0F8F %numerate_string_fail  ; jg %numerate_string_fail    # If CH > '9'
	83F9 00                     ; cmp_ecx, !0                 # Check for illegal
	0F8C %numerate_string_fail  ; jl %numerate_string_fail    # IF CH < 0
	01C8                        ; add_eax,ecx                 # VALUE = VALUE + CH
	83C3 01                     ; add_ebx, !1                 # S = S + 1
	E9 %numerate_decimal        ; jmp %numerate_decimal       # Keep looping

:numerate_decimal_done
	83FF 01                     ; cmp_edi, !1                 # Check if need to negate
	0F85 %numerate_string_done  ; jne %numerate_string_done   # Nope

	6BC0 FF                     ; imul_eax, !-1               # VALUE = VALUE * -1
	E9 %numerate_string_done    ; jmp %numerate_string_done   # Done

:numerate_hex
	83C3 02                     ; add_ebx, !2                 # S = S + 2
:numerate_hex_loop
	8A0B                        ; mov_cl,[ebx]                # S[0]
	0FB6C9                      ; movzx_ecx,cl                # make it useful
	83F9 00                     ; cmp_ecx, !0                 # IF NULL == S[0]
	0F84 %numerate_string_done  ; je %numerate_string_done    # We are done

	C1E0 04                     ; shl_eax, !4                 # VALUE = VALUE << 4
	83E9 30                     ; sub_ecx, !48                # CH = CH - '0'
	83F9 0A                     ; cmp_ecx, !10                # IF 10 >= CH
	0F8C %numerate_hex_digit    ; jl %numerate_hex_digit      # NO
	83E9 07                     ; sub_ecx, !7                 # Push A-F into range
:numerate_hex_digit
	83F9 0F                     ; cmp_ecx, !15                # Check for illegal
	0F8F %numerate_string_fail  ; jg %numerate_string_fail    # If CH > 'F'
	83F9 00                     ; cmp_ecx, !0                 # Check for illegal
	0F8C %numerate_string_fail  ; jl %numerate_string_fail    # IF CH < 0
	01C8                        ; add_eax,ecx                 # VALUE = VALUE + CH
	83C3 01                     ; add_ebx, !1                 # S = S + 1
	E9 %numerate_hex_loop       ; jmp %numerate_hex_loop      # Keep looping

:numerate_string_fail
	B8 00000000                 ; mov_eax, %0                 # return ZERO

:numerate_string_done
	5F                          ; pop_edi                     # Restore EDI
	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# express_number function
# Receives INT in EAX and CHAR in EBX
# Allocates a string and expresses the value in hex
# Returns string in EAX
# Uses EAX for VALUE, EBX for S and ECX for CH
:express_number
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
	89D9                        ; mov_ecx,ebx                 # Put CH in right place
	89C3                        ; mov_ebx,eax                 # Protect VALUE
	83F9 25                     ; cmp_ecx, !37                # IF '%' == CH
	0F85 %express_number2       ; jne %express_number2        # Otherwise try @

	B8 09000000                 ; mov_eax, %9                 # We need 3 bytes
	E8 %malloc                  ; call %malloc                # Get S pointer
	93                          ; xchg_eax,ebx                # Put S and VALUE in place
	53                          ; push_ebx                    # Protect S
	E8 %hex32l                  ; call %hex32l                # Store 32bits
	E9 %express_number_done     ; jmp %express_number_done    # done

:express_number2
	83F9 40                     ; cmp_ecx, !64                # IF '@' == CH
	0F85 %express_number1       ; jne %express_number1        # Othrewise try !

	B8 05000000                 ; mov_eax, %5                 # We need 3 bytes
	E8 %malloc                  ; call %malloc                # Get S pointer
	93                          ; xchg_eax,ebx                # Put S and VALUE in place
	53                          ; push_ebx                    # Protect S
	E8 %hex16l                  ; call %hex16l                # Store 16bits
	E9 %express_number_done     ; jmp %express_number_done    # done

:express_number1
	B8 03000000                 ; mov_eax, %3                 # We need 3 bytes
	E8 %malloc                  ; call %malloc                # Get S pointer
	93                          ; xchg_eax,ebx                # Put S and VALUE in place
	53                          ; push_ebx                    # Protect S
	E8 %hex8                    ; call %hex8                  # Store 8bit

:express_number_done
	58                          ; pop_eax                     # Restore S
	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# HEX to ascii routine
# Receives INT in EAX and CHAR* in EBX
# Stores ascii of INT in CHAR*
# Returns only modifying EAX
:hex64l
	50                          ; push_eax                    # Protect top 32
	E8 %hex32l                  ; call %hex32l                # Store it
	58                          ; pop_eax                     # do top 32
	C1E8 20                     ; shr_eax, !32                # do bottom 32 first
:hex32l
	50                          ; push_eax                    # Protect top 16
	E8 %hex16l                  ; call %hex16l                # Store it
	58                          ; pop_eax                     # do top 16
	C1E8 10                     ; shr_eax, !16                # do bottom 16 first
:hex16l
	50                          ; push_eax                    # Protect top byte
	E8 %hex8                    ; call %hex8                  # Store it
	58                          ; pop_eax                     # do high byte
	C1E8 08                     ; shr_eax, !8                 # do bottom byte first
:hex8
	50                          ; push_eax                    # Protect bottom nibble
	C1E8 04                     ; shr_eax, !4                 # do high nibble first
	E8 %hex4                    ; call %hex4                  # Store it
	58                          ; pop_eax                     # do low nibble
:hex4
	83E0 0F                     ; and_eax, !0xF               # isolate nibble
	04 30                       ; add_al, !48                 # convert to ascii
	3C 39                       ; cmp_al, !57                 # valid digit?
	0F86 %hex1                  ; jbe %hex1                   # yes
	04 07                       ; add_al, !7                  # use alpha range
:hex1
	8803                        ; mov_[ebx],al                # store result
	83C3 01                     ; add_ebx, !1                 # next position
	C3                          ; ret


# Preserve_Other function
# Receives List in EAX
# Updates the list in place; does not modify registers
# Uses EAX for I, EBX for I->TEXT
:Preserve_Other
	50                          ; push_eax                    # Protect EAX
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	52                          ; push_edx                    # Protect EDX
:Preserve_Other_Loop
	8B58 18                     ; mov_ebx,[eax+BYTE] !24      # I->EXPRESSION
	83FB 00                     ; cmp_ebx, !0                 # IF NULL == I->EXPRESSION
	0F85 %Preserve_Other_Next   ; jne %Preserve_Other_Next    # Otherwise next

	# Needs preserving
	8B58 10                     ; mov_ebx,[eax+BYTE] !16      # I->TEXT
	8958 18                     ; mov_[eax+BYTE],ebx !24      # I->EXPRESSION = I->TEXT

:Preserve_Other_Next
	8B00                        ; mov_eax,[eax]               # I = I->NEXT
	83F8 00                     ; cmp_eax, !0                 # IF NULL == I
	0F85 %Preserve_Other_Loop   ; jne %Preserve_Other_Loop    # Otherwise keep looping

	5A                          ; pop_edx                     # Restore EDX
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	58                          ; pop_eax                     # Restore EAX
	C3                          ; ret


# Print_Hex function
# Receives list in EAX
# walks the list and prints the I->EXPRESSION for all nodes followed by newline
# Uses EBX for I
:Print_Hex
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	89EB                        ; mov_ebx,ebp                 # I = Head
:Print_Hex_Loop
	8B43 08                     ; mov_eax,[ebx+BYTE] !8       # I->TYPE
	83F8 01                     ; cmp_eax, !1                 # IF MACRO == I->TYPE
	0F84 %Print_Hex_Next        ; je %Print_Hex_Next          # Skip

	8B43 18                     ; mov_eax,[ebx+BYTE] !24      # Using EXPRESSION
	E8 %File_Print              ; call %File_Print            # Print it
	B8 0A000000                 ; mov_eax, %10                # NEWLINE
	E8 %fputc                   ; call %fputc                 # Append it

:Print_Hex_Next
	8B1B                        ; mov_ebx,[ebx]               # Iterate to next Token
	83FB 00                     ; cmp_ebx, !0                 # Check for NULL
	0F85 %Print_Hex_Loop        ; jne %Print_Hex_Loop         # Otherwise keep looping

	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# File_Print function
# Receives CHAR* in EAX
# calls fputc for every non-null char
:File_Print
	53                          ; push_ebx                    # Protect EBX
	51                          ; push_ecx                    # Protect ECX
	89C3                        ; mov_ebx,eax                 # Protect S
	83F8 00                     ; cmp_eax, !0                 # Protect against nulls
	0F84 %File_Print_Done       ; je %File_Print_Done         # Simply don't try to print them
:File_Print_Loop
	8A03                        ; mov_al,[ebx]                # Read byte
	0FB6C0                      ; movzx_eax,al                # zero extend
	83F8 00                     ; cmp_eax, !0                 # Check for NULL
	0F84 %File_Print_Done       ; je %File_Print_Done         # Stop at NULL

	E8 %fputc                   ; call %fputc                 # write it
	83C3 01                     ; add_ebx, !1                 # S = S + 1
	E9 %File_Print_Loop         ; jmp %File_Print_Loop        # Keep going

:File_Print_Done
	59                          ; pop_ecx                     # Restore ECX
	5B                          ; pop_ebx                     # Restore EBX
	C3                          ; ret


# fputc function
# receives CHAR in EAX and FILE* in [Output]
# writes char and returns
:fputc
	52                          ; push_edx                    # Protect EDX
	51                          ; push_ecx                    # protect ECX
	53                          ; push_ebx                    # protect EBX
	50                          ; push_eax                    # We are writing eax
	8D0C24                      ; lea_ecx,[esp]               # Get stack address
	8B1D &Output                ; mov_ebx,[DWORD] &Output     # Write to target file
	B8 04000000                 ; mov_eax, %4                 # the syscall number for write
	BA 01000000                 ; mov_edx, %1                 # set the size of chars we want
	CD 80                       ; int !0x80                   # call the Kernel
	58                          ; pop_eax                     # Restore stack
	5B                          ; pop_ebx                     # Restore EBX
	59                          ; pop_ecx                     # Restore ECX
	5A                          ; pop_edx                     # Restore EDX
	C3                          ; ret

:Output
	00000000                    ; %0
:Input
	00000000                    ; %0
:ELF_end
