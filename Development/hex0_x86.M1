;; Copyright (C) 2017 Jeremiah Orians
;; Copyright (C) 2022 Andrius Å tikonas
;; This file is part of stage0.
;;
;; stage0 is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; stage0 is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with stage0.  If not, see <http://www.gnu.org/licenses/>.

DEFINE ADD_EDI_to_EAX 01F8
DEFINE CALL E8
DEFINE CMPI8_AL 3C
DEFINE COPY_EAX_to_EDI 89C7
DEFINE COPY_EAX_to_EDX 89C2
DEFINE COPY_EAX_to_ESI 89C6
DEFINE COPY_EDX_to_EBX 89D3
DEFINE COPY_ESP_to_ECX 89E1
DEFINE COPY_ESI_to_EBX 89F3
DEFINE DEC_EBP 4D
DEFINE INT_80 CD80
DEFINE JE8 74
DEFINE JGE8 7D
DEFINE JL8 7C
DEFINE JMP8 EB
DEFINE JNE8 75
DEFINE LOADI16_CX 66B9
DEFINE LOADI16_DX 66BA
DEFINE NULL 00000000
DEFINE POP_EAX 58
DEFINE POP_EBX 5B
DEFINE POP_EBP 5D
DEFINE POP_EDX 5A
DEFINE PUSH_EAX 50
DEFINE PUSH_EBX 53
DEFINE PUSH_EDX 52
DEFINE PUSH 6A
DEFINE RET C3
DEFINE SHLI8_EDI C1E7
DEFINE SUBI8_AL 2C
DEFINE TEST 85C0
DEFINE TEST_EBP_EBP 85ED
DEFINE XOR_EBP_EBP 31ED
DEFINE XOR_EBX_EBX 31DB
DEFINE XOR_ECX_ECX 31C9
DEFINE XOR_EDI_EDI 31FF
DEFINE XOR_EDX_EDX 31D2

; Where the ELF Header is going to hit
; Simply jump to _start
; Our main function
:_start
	POP_EAX                     ; Get the number of arguments
	POP_EBX                     ; Get the program name
	POP_EBX                     ; Get the actual input name
	XOR_ECX_ECX                 ; prepare read_only, ecx = 0
	XOR_EDX_EDX                 ; Extra sure, edx = 0
	PUSH !5                     ; prepare to set eax to 5
	POP_EAX                     ; the syscall number for open()
	INT_80                      ; Now open that damn file
	COPY_EAX_to_ESI             ; Preserve the file pointer we were given

	POP_EBX                     ; Get the actual output name
	LOADI16_CX @577             ; Prepare file as O_WRONLY|O_CREAT|O_TRUNC
	LOADI16_DX @448             ; Prepare file as RWX for owner only (700 in octal)
	PUSH !5                     ; prepare to set eax to 5
	POP_EAX                     ; the syscall number for open()
	INT_80                      ; Now open that damn file
	COPY_EAX_to_EDX             ; Preserve the file pointer we were given

	; Our flag for byte processing
	PUSH !-1
	POP_EBP                     ; ebp = -1

	; temp storage for the sum
	XOR_EDI_EDI                 ; edi = 0

:loop
	; Read a byte
	CALL %Read_byte

	; process byte
	CALL %hex

	; Deal with -1 values
	TEST
	JL8 !loop

	; deal with toggle
	TEST_EBP_EBP                ; jump if ebp >= 0
	JGE8 !print

	; process first byte of pair
	COPY_EAX_to_EDI
	XOR_EBP_EBP                 ; ebp = 0
	JMP8 !loop

; process second byte of pair
:print
	; update the sum and store in output
	SHLI8_EDI !4
	ADD_EDI_to_EAX

	; flip the toggle
	DEC_EBP                     ; ebp = -1

	CALL %write_byte

	JMP8 !loop

:hex
	; Purge Comment Lines (#)
	CMPI8_AL !35
	JE8 !purge_comment

	; Purge Comment Lines (;)
	CMPI8_AL !59
	JE8 !purge_comment

	; deal all ascii less than 0
	CMPI8_AL !48
	JL8 !ascii_other

	; deal with 0-9
	CMPI8_AL !58
	JL8 !ascii_num

	; deal with all ascii less than A
	CMPI8_AL !65
	JL8 !ascii_other

	; deal with A-F
	CMPI8_AL !71
	JL8 !ascii_high

	;deal with all ascii less than a
	CMPI8_AL !97
	JL8 !ascii_other

	;deal with a-f
	CMPI8_AL !103
	JL8 !ascii_low

	; The rest that remains needs to be ignored
	JMP8 !ascii_other

:purge_comment
	; Read a byte
	CALL %Read_byte

	; Loop if not LF
	CMPI8_AL !10
	JNE8 !purge_comment

	; Otherwise return -1

:ascii_other
	PUSH !-1
	POP_EAX                     ; return -1
	RET

:ascii_num
	SUBI8_AL !48
	RET

:ascii_low
	SUBI8_AL !32                ; convert to uppercase

:ascii_high
	SUBI8_AL !55
	RET

; Writes byte stored in al
:write_byte
	; Print our Hex
	COPY_EDX_to_EBX             ; Where are we writing to
	PUSH_EDX                    ; protect fout
	PUSH !1                     ; prepare to set edx to 1
	POP_EDX                     ; set the size of chars we want
	PUSH_EAX                    ; Move output to stack
	COPY_ESP_to_ECX             ; What we are writing
	PUSH !4                     ; prepare to set eax to 4
	POP_EAX                     ; the syscall number for write
	INT_80                      ; call the Kernel
	POP_EBX                     ; deallocate stack
	POP_EDX                     ; restore fout
	RET

:Read_byte
	; Attempt to read 1 byte from Input file
	PUSH_EDX                    ; protect fout
	PUSH !1                     ; prepare to set edx to 1
	POP_EDX                     ; set the size of chars we want
	PUSH_EBX                    ; allocate stack
	COPY_ESP_to_ECX             ; Where to put it
	COPY_ESI_to_EBX             ; Where are we reading from
	PUSH !3                     ; prepare to set eax to 3
	POP_EAX                     ; the syscall number for read
	INT_80                      ; call the Kernel

	TEST                        ; check what we got
	JE8 !Done                   ; Got EOF call it done

	; load byte
	POP_EAX                     ; load char
	POP_EDX                     ; restore fout
	RET

:Done
	; program completed Successfully
	XOR_EBX_EBX                 ; All is well, ebx = 0
	PUSH !1
	POP_EAX                     ; put the exit syscall number in eax
	INT_80                      ; Call it a good day

:ELF_end
