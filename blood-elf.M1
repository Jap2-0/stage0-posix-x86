
# Core program
# Defining function exit
:FUNCTION_exit
POP_ebx
POP_ebx
LOAD_IMMEDIATE_eax %1
INT_80
RETURN
# Defining function fgetc
:FUNCTION_fgetc
LOAD_IMMEDIATE_eax %3
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
PUSH_ebx
COPY_esp_to_ecx
LOAD_IMMEDIATE_edx %1
INT_80
TEST
POP_eax
JUMP_NE8 !FUNCTION_fgetc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_fgetc_Done
RETURN
# Defining function fputc
:FUNCTION_fputc
LOAD_IMMEDIATE_eax %4
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_IMMEDIATE_edx %1
INT_80
RETURN
# Defining function open
:FUNCTION_open
LOAD_EFFECTIVE_ADDRESS_ebx %12
LOAD_INTEGER_ebx
LOAD_EFFECTIVE_ADDRESS_ecx %8
LOAD_INTEGER_ecx
LOAD_EFFECTIVE_ADDRESS_edx %4
LOAD_INTEGER_edx
LOAD_IMMEDIATE_eax %5
INT_80
RETURN
# Defining function fopen
:FUNCTION_fopen
# Defining local f
PUSH_eax	#f
# IF_fopen_0
LOAD_IMMEDIATE_eax %119
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %577
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %384
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_fopen_0
:ELSE_fopen_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_open
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:_END_IF_fopen_0
# IF_fopen_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETG
MOVEZBL
TEST
JUMP_EQ %ELSE_fopen_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_fopen_1
:ELSE_fopen_1
:_END_IF_fopen_1
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function close
:FUNCTION_close
LOAD_EFFECTIVE_ADDRESS_ebx %4
LOAD_IMMEDIATE_eax %6
INT_80
RETURN
# Defining function fclose
:FUNCTION_fclose
# Defining local error
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_close
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#error
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function file_print
:FUNCTION_file_print
:WHILE_file_print_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_file_print_0
# THEN_while_file_print_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fputc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_file_print_0
:END_WHILE_file_print_0
RETURN
# Defining function malloc
:FUNCTION_malloc
STORE_eax_into_ESP_IMMEDIATE8 !4
PUSH_eax
LOAD_IMMEDIATE_eax %45
LOAD_IMMEDIATE_ebx %0
INT_80
POP_ebx
ADD_eax_to_ebx
PUSH_eax
PUSH_ebx
LOAD_IMMEDIATE_eax %45
INT_80
POP_ebx
CMP
POP_eax
JUMP_EQ8 !FUNCTION_malloc_Done
LOAD_IMMEDIATE_eax %-1
:FUNCTION_malloc_Done
RETURN
# Defining function memset
:FUNCTION_memset
# Defining local s
PUSH_eax	#s
# FOR_initialization_memset_0
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_memset_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETL
MOVEZBL
TEST
JUMP_EQ %FOR_END_memset_0
JUMP %FOR_THEN_memset_0
:FOR_ITER_memset_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_memset_0
:FOR_THEN_memset_0
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_ITER_memset_0
:FOR_END_memset_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function calloc
:FUNCTION_calloc
# Defining local ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_malloc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#ret
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
POP_ebx	# _common_recursion
MULTIPLY_eax_by_ebx_into_eax
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_memset
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _return_result_locals
RETURN
# Defining function free
:FUNCTION_free
RETURN
# Defining function match
:FUNCTION_match
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
SUBTRACT_eax_from_ebx_into_ebx
MOVE_ebx_to_eax
PUSH_eax	#i
:DO_match_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_match_1
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %ELSE_match_1
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_match_1
:ELSE_match_1
:_END_IF_match_1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_NE %DO_match_0
:DO_END_match_0
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
RETURN
# Defining function consume_token
:FUNCTION_consume_token
# Defining local i
LOAD_IMMEDIATE_eax %0
PUSH_eax	#i
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
:DO_consume_token_0
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_CHAR
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-20
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax %32
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %9
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %62
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-20
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_NE %DO_consume_token_0
:DO_END_consume_token_0
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function storeLabel
:FUNCTION_storeLabel
# Defining local entry
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#entry
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %4096
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_consume_token
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# IF_storeLabel_0
LOAD_IMMEDIATE_eax %95
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
ADD_ebx_to_eax
LOAD_BYTE
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_storeLabel_0
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_storeLabel_0
:ELSE_storeLabel_0
:_END_IF_storeLabel_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function line_Comment
:FUNCTION_line_Comment
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
:WHILE_line_Comment_0
LOAD_IMMEDIATE_eax %10
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %13
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %END_WHILE_line_Comment_0
# THEN_while_line_Comment_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_line_Comment_0
:END_WHILE_line_Comment_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function purge_string
:FUNCTION_purge_string
# Defining local c
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#c
:WHILE_purge_string_0
LOAD_IMMEDIATE_eax %0xFFFFFFFF
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %34
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
POP_ebx	# _common_recursion
AND_eax_ebx
TEST
JUMP_EQ %END_WHILE_purge_string_0
# THEN_while_purge_string_0
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_purge_string_0
:END_WHILE_purge_string_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function first_pass
:FUNCTION_first_pass
# IF_first_pass_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_0
RETURN
JUMP %_END_IF_first_pass_0
:ELSE_first_pass_0
:_END_IF_first_pass_0
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_first_pass
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
# Defining local source_file
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_first_pass_1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#source_file
# IF_first_pass_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_2
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_first_pass_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_first_pass_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_first_pass_2
:ELSE_first_pass_2
:_END_IF_first_pass_2
# Defining local c
PUSH_eax	#c
# FOR_initialization_first_pass_5
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_first_pass_5
LOAD_IMMEDIATE_eax %0xFFFFFFFF
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_first_pass_5
JUMP %FOR_THEN_first_pass_5
:FOR_ITER_first_pass_5
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fgetc
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_first_pass_5
:FOR_THEN_first_pass_5
# IF_first_pass_6
LOAD_IMMEDIATE_eax %58
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_6
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_storeLabel
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_first_pass_6
:ELSE_first_pass_6
# IF_first_pass_7
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %35
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %59
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_first_pass_7
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_line_Comment
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_first_pass_7
:ELSE_first_pass_7
# IF_first_pass_8
LOAD_IMMEDIATE_eax %34
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_first_pass_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_purge_string
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_first_pass_8
:ELSE_first_pass_8
:_END_IF_first_pass_8
:_END_IF_first_pass_7
:_END_IF_first_pass_6
JUMP %FOR_ITER_first_pass_5
:FOR_END_first_pass_5
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fclose
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _recursive_statement_locals
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function output_debug
:FUNCTION_output_debug
# Defining local i
PUSH_eax	#i
# FOR_initialization_output_debug_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
:FOR_output_debug_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %FOR_END_output_debug_0
JUMP %FOR_THEN_output_debug_0
:FOR_ITER_output_debug_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %FOR_output_debug_0
:FOR_THEN_output_debug_0
# IF_output_debug_1
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
TEST
JUMP_EQ %ELSE_output_debug_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_output_debug_2
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_output_debug_3
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_output_debug_4
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_output_debug_1
:ELSE_output_debug_1
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_output_debug_5
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_output_debug_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_output_debug_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_output_debug_1
JUMP %FOR_ITER_output_debug_0
:FOR_END_output_debug_0
POP_ebx	# _recursive_statement_locals
RETURN
# Defining function reverse_list
:FUNCTION_reverse_list
# Defining local root
LOAD_IMMEDIATE_eax %0
PUSH_eax	#root
# Defining local next
PUSH_eax	#next
:WHILE_reverse_list_0
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETNE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_reverse_list_0
# THEN_while_reverse_list_0
LOAD_BASE_ADDRESS_eax %-16
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %WHILE_reverse_list_0
:END_WHILE_reverse_list_0
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
# Defining function main
:FUNCTION_main
COPY_esp_to_ebp	# Deal with special case
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local input
LOAD_IMMEDIATE_eax %0
PUSH_eax	#input
LOAD_IMMEDIATE_eax &GLOBAL_output
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
STORE_INTEGER
# Defining local output_file
LOAD_IMMEDIATE_eax &STRING_main_0
PUSH_eax	#output_file
# Defining local option_index
LOAD_IMMEDIATE_eax %1
PUSH_eax	#option_index
:WHILE_main_1
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETLE
MOVEZBL
TEST
JUMP_EQ %END_WHILE_main_1
# THEN_while_main_1
# IF_main_2
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_2
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_2
:ELSE_main_2
# IF_main_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_4
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_5
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_3
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_6
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %0
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_7
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_3
:ELSE_main_3
# IF_main_8
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_9
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_10
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_8
# Defining local temp
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %8
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_calloc
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#temp
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
# looking up offset
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-4
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-16
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
POP_ebx	# _recursive_statement_locals
JUMP %_END_IF_main_8
:ELSE_main_8
# IF_main_11
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_12
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_13
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_11
LOAD_BASE_ADDRESS_eax %-8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %1
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
POP_ebx	# _common_recursion
STORE_INTEGER
LOAD_IMMEDIATE_eax &GLOBAL_output
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-8
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_14
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_fopen
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
# IF_main_15
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_15
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_16
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
# looking up offset
# -> offset calculation
LOAD_IMMEDIATE_ebx %4
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_17
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_15
:ELSE_main_15
:_END_IF_main_15
LOAD_BASE_ADDRESS_eax %-12
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
PUSH_eax	#_common_recursion
LOAD_IMMEDIATE_eax %2
POP_ebx	# _common_recursion
ADD_ebx_to_eax
POP_ebx	# _common_recursion
STORE_INTEGER
JUMP %_END_IF_main_11
:ELSE_main_11
# IF_main_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_19
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %8
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-12
LOAD_INTEGER
POP_ebx	# _common_recursion
SAL_eax_Immediate8 !2
ADD_ebx_to_eax
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &STRING_main_20
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_match
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
OR_eax_ebx
TEST
JUMP_EQ %ELSE_main_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_21
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
JUMP %_END_IF_main_18
:ELSE_main_18
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_22
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %2
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_exit
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
:_END_IF_main_18
:_END_IF_main_11
:_END_IF_main_8
:_END_IF_main_3
:_END_IF_main_2
JUMP %WHILE_main_1
:END_WHILE_main_1
# IF_main_23
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_common_recursion
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
POP_ebx	# _common_recursion
CMP
SETE
MOVEZBL
TEST
JUMP_EQ %ELSE_main_23
LOAD_IMMEDIATE_eax %1
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN
JUMP %_END_IF_main_23
:ELSE_main_23
:_END_IF_main_23
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_BASE_ADDRESS_eax %-4
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_first_pass
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
PUSH_eax	#_common_recursion
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
PUSH_eax	#_process_expression1
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_reverse_list
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
POP_ebx	# _common_recursion
STORE_INTEGER
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_24
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %1
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_output_debug
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_25
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &GLOBAL_jump_table
LOAD_INTEGER
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax %0
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_output_debug
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
PUSH_edi	# Prevent overwriting in recursion
PUSH_ebp	# Protect the old base pointer
COPY_esp_to_edi	# Copy new base pointer
LOAD_IMMEDIATE_eax &STRING_main_26
PUSH_eax	#_process_expression1
LOAD_IMMEDIATE_eax &GLOBAL_output
LOAD_INTEGER
PUSH_eax	#_process_expression2
COPY_edi_to_ebp
CALL_IMMEDIATE %FUNCTION_file_print
POP_ebx	# _process_expression_locals
POP_ebx	# _process_expression_locals
POP_ebp	# Restore old base pointer
POP_edi	# Prevent overwrite
LOAD_IMMEDIATE_eax %0
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
POP_ebx	# _return_result_locals
RETURN

:ELF_data
# Program global variables
:GLOBAL_output
NOP
:GLOBAL_jump_table
NOP

# Program strings
:STRING_first_pass_1
"r"
:STRING_first_pass_3
"The file: "
:STRING_first_pass_4
" can not be opened!
"
:STRING_output_debug_2
":ELF_str_"
:STRING_output_debug_3
' 0A 22 00'
:STRING_output_debug_4
' 22 0A 00'
:STRING_output_debug_5
"%ELF_str_"
:STRING_output_debug_6
">ELF_str
&"
:STRING_output_debug_7
"
%10000
!2
!0
@1
"
:STRING_main_0
""
:STRING_main_4
"-h"
:STRING_main_5
"--help"
:STRING_main_6
"Usage: "
:STRING_main_7
" -f FILENAME1 {-f FILENAME2}
"
:STRING_main_9
"-f"
:STRING_main_10
"--file"
:STRING_main_12
"-o"
:STRING_main_13
"--output"
:STRING_main_14
"w"
:STRING_main_16
"The file: "
:STRING_main_17
" can not be opened!
"
:STRING_main_19
"-V"
:STRING_main_20
"--version"
:STRING_main_21
"blood-elf 0.1
(Basically Launches Odd Object Dump ExecutabLe Files
"
:STRING_main_22
"Unknown option
"
:STRING_main_24
":ELF_str
!0
"
:STRING_main_25
' 25 30 0A 3A 45 4C 46 5F 73 79 6D 0A 25 30 0A 25 30 0A 25 30 0A 21 30 0A 21 30 0A 40 31 0A 00'
:STRING_main_26
' 0A 3A 45 4C 46 5F 65 6E 64 0A 00'

:ELF_end
